# Data
***

## Types

#### **Basic Types**. {-}
The two basic types of data are *cardinal* (aka numeric) data and *factor* data. We can further distinguish between whether cardinal data are discrete or continuous. We can also further distinguish between whether factor data are ordered or not

* *Cardinal (Numeric)*: the difference between elements always means the same thing. 
    * Discrete: E.g., $2-1=3-2$.
    * Continuous: E.g., $2.9-1.4348=3.9-2.4348$
* *Factor*: the difference between elements does not always mean the same thing.
    * Ordered: E.g., First place - Second place ?? Second place - Third place.
    * Unordered (categorical): E.g., A - B ????


Here are some examples
```{r}
dat_card1 <- 1:3 # Cardinal data (Discrete)
dat_card1

dat_card2 <- c(1.1, 2/3, 3) # Cardinal data (Continuous)
dat_card2

dat_fact1 <- factor( c('A','B','C'), ordered=T) # Factor data (Ordinal)
dat_fact1

dat_fact2 <- factor( c('Leipzig','Los Angeles','Logan'), ordered=F) # Factor data (Categorical)
dat_fact2

dat_fact3 <- factor( c(T,F), ordered=F) # Factor data (Categorical)
dat_fact3

# Explicitly check the data types:
#class(dat_card1)
#class(dat_card2)
```

Note that for theoretical analysis, the types are sometimes grouped differently as

* continuous (continuous cardinal data)
* discrete (discrete cardinal, ordered factor, and unordered factor data)

In any case, data are often computationally analyzed as `data.frame` objects, discussed below.


#### **Strings**. {-} 
Note that R allows for unstructured plain text, called *character strings*, which we can then format as factors
```{r}
c('A','B','C')  # character strings
c('Leipzig','Los Angeles','Logan')  # character strings
```
Also note that strings are encounter in a variety of settings, and you often have to format them after reading them into R.^[We will not cover the statistical analysis of text in this course, but strings are amenable to statistical analysis.]
```{r}
# Strings
paste( 'hi', 'mom')
paste( c('hi', 'mom'), collapse='--')

kingText <- "The king infringes the law on playing curling."
gsub(pattern="ing", replacement="", kingText)
# advanced usage
#gsub("[aeiouy]", "_", kingText)
#gsub("([[:alpha:]]{3})ing\\b", "\\1", kingText) 
```
See 

* <https://meek-parfait-60672c.netlify.app/docs/M1_R-intro_03_text.html>
* <https://raw.githubusercontent.com/rstudio/cheatsheets/main/regex.pdf>


## Datasets

Datasets can be stored in a variety of formats on your computer. But they can be analyzed in R in three basic ways.

#### **Lists**. {-}

Lists are probably the most basic type
```{r}
x <- 1:10
y <- 2*x
list(x, y)  # list of vectors

x_mat1 <- matrix(2:7,2,3)
x_mat2 <- matrix(4:-1,2,3)
list(x_mat1, x_mat2)  # list of matrices
```

Lists are useful for storing unstructured data
```{r}
list(list(x_mat1), list(x_mat2))  # list of lists

list(x_mat1, list(x_mat1, x_mat2)) # list of different objects

# ...inception...
list(x_mat1,
    list(x_mat1, x_mat2), 
    list(x_mat1, list(x_mat2)
    )) 
```

#### **Data.frames**. {-}

A *data.frame* looks like a matrix but each column is actually a list rather than a vector. This allows you to combine different data types into a single object for analysis, which is why it might be your most common object.

```{r}
# data.frames: your most common data type
    # matrix of different data-types
    # well-ordered lists
data.frame(x, y)  # list of vectors

# Storing different types of data
d0 <- data.frame(x=dat_fact2, y=dat_card2)
d0

d0[,'y'] #d0$y
```

#### **Arrays**. {-}

Arrays are generalization of matrices to multiple dimensions. They are a very efficient way to store well-formatted numeric data, and are often used in spatial econometrics and time series (often in the form of "data cubes").

```{r}
# data square (matrix)
array(data = 1:24, dim = c(3,8))

# data cube
a <- array(data = 1:24, dim = c(3, 2, 4))
a
```

```{r, eval=F}
a[1, , , drop = FALSE]  # Row 1
#a[, 1, , drop = FALSE]  # Column 1
#a[, , 1, drop = FALSE]  # Layer 1

a[ 1, 1,  ]  # Row 1, column 1
#a[ 1,  , 1]  # Row 1, "layer" 1
#a[  , 1, 1]  # Column 1, "layer" 1
a[1 , 1, 1]  # Row 1, column 1, "layer" 1
```

Apply extends to arrays
```{r}
apply(a, 1, mean)    # Row means
apply(a, 2, mean)    # Column means
apply(a, 3, mean)    # "Layer" means
apply(a, 1:2, mean)  # Row/Column combination 
```

Outer products yield arrays
```{r}
x <- c(1,2,3)
x_mat1 <- outer(x, x) # x %o% x
x_mat1
is.array(x_mat1) # Matrices are arrays

x_mat2 <- matrix(6:1,2,3)
outer(x_mat2, x)
# outer(x_mat2, matrix(x))
# outer(x_mat2, t(x))
# outer(x_mat1, x_mat2)
```


## Densities and Distributions

#### **Initial Data Inspection**. {-}
Regardless of the data types you have, you typically begin by inspecting your data by examining the first few observations.
 
Consider, for example, historical data on crime in the US.

```{r}
head(USArrests)

# Check NA values
X <- c(1,NA,2,3)
sum(is.na(X))
```

To further examine a particular variable, we look at its distribution. In what follows, we will often work with data as vector $X=(X_{1}, X_{2}, ....X_{N})$, where there are $N$ observations and $X_{i}$ is the value of the $i$th one.


#### **Histogram Density Estimate**. {-}
The histogram divides the range of the data into $L$ exclusive bins of equal-width $h$, and count the number of observations within each bin. We often rescale the counts so that the total area of all bins sums to one, which allows us to interpret the numbers as a *density* measuring a proportion of the data in each bin. Mathematically, for an exclusive bin $\left(x-\frac{h}{2}, x+\frac{h}{2} \right]$ defined by their midpoint $x$ and width $h$, we compute
\begin{eqnarray}
\widehat{f}_{HIST}(x) &=& \frac{  \sum_{i=1}^{N} \mathbf{1}\left( X_{i} \in \left(x-\frac{h}{2}, x+\frac{h}{2} \right] \right) }{N h}.
\end{eqnarray}
Note that $\mathbf{1}()$ is an indicator function, which equals $1$ if the expression inside is `TRUE` and $0$ otherwise. I.e., if $x-\frac{h}{2} < X_{i} \leq x+\frac{h}{2}$ then $\mathbf{1}\left( X_{i} \in \left(x-\frac{h}{2}, x+\frac{h}{2} \right] \right) =1$. Also note that we compute $\widehat{f}_{HIST}(x)$ for each bin midpoint $x$.^[If the bins exactly span the range, then $h=[\text{max}(X_{i}) - \text{min}(X_{i})]/L$ and $x\in \left\{ \frac{\ell h}{2} + \text{min}(X_{i}) \right\}_{\ell=1}^{L}$.]

For example, let $X=(3,3.1,0.02)$ and use bins $(0,1], (1,2], (2,3], (3,4]$. In this case, the midpoints are $x=(0.5,1.5,2.5,3.5)$ and $h=1$. Then the counts at each midpoints are $(1,0,0,2)$. Since $\frac{1}{Nh}=1/3$, we also have $\widehat{f}(x)=(1/3,0,1/3,1/3)$. Now intuitively work through an example with three bins instead of four.
```{r, eval=F}
# Intuitive Examples
X <- c(3,3.1,0.02)
hist(X, breaks=c(0,1,2,3,4), plot=F)

hist(X, breaks=c(0,4/3,8/3,4), plot=F)

# as a default, R uses bins (,] instead of [,)
# but you can change that 
hist(X, breaks=c(0,4/3,8/3,4), plot=F, right=F)
```

```{r}
# Practical Example
hist(USArrests[,'Murder'], freq=F, breaks=20,
    border=NA, 
    main='',
    xlab='Murder Arrests',
    ylab='Proportion of States in each bin')
# Raw Observations
rug(USArrests[,'Murder'], col=grey(0,.5))
```

Note that if you your data are factor data, or discrete cardinal data, you can directly plot the counts or proportions: for each unique outcome $x$ we compute $\widehat{p}_{x}=\sum_{i=1}^{N}\mathbf{1}\left(X_{i}=x\right)/N$.
```{r}
# Discretized data
xr <- floor(USArrests[,'Murder']) #rounded down
#table(xr)
proportions <- table(xr)/length(xr)
plot(proportions, col=grey(0,.5),
    xlab='Murder Rate (Discretized)',
    ylab='Proportion of States with each value')
```

#### **Empirical *Cumulative* Distribution Function**. {-}
The ECDF counts the proportion of observations whose values are less than or equal to $x$; 
\begin{eqnarray}
\widehat{F}_{ECDF}(x) = \frac{1}{N} \sum_{i}^{N} \mathbf{1}(X_{i} \leq x).
\end{eqnarray}
Typically, we compute this for each unique value of $x$ in the dataset, but sometimes other values of $x$ too.

For example, let $X=(3,3.1,0.02)$ and consider the points $x=(0.5,1.5,2.5,3.5)$. Then the counts are $(1,1,1,3)$. Since $N=3$, $\widehat{F}(x)=(1/3,1/3,1/3,1)$.

```{r}
F_murder <- ecdf(USArrests[,'Murder'])
# proportion of murders <= 10
F_murder(10)
# proportion of murders <= x, for all x
plot(F_murder, main='', xlab='Murder Arrests',
    pch=16, col=grey(0,.5))
rug(USArrests[,'Murder'])
```

#### **Boxplots**. {-}
Boxplots summarize the distribution of data using *quantiles*: the $q$th quantile is the value where $q$ percent of the data are below and ($1-q$) percent are above.

* The *median* is the point where half of the data has lower values and the other half has higher values.
* The *lower quartile* is the point where $25%$ of the data has lower values and the other $75%$ has higher values.
* The *min* is the smallest value (or the most negative value if there are any), where $0%$ of the data has lower values.

For example, if $X=(0,0,0.02,3,5)$ then the median is $0.02$, the lower quartile is $0$, and the upper quartile is $3$. (The number $0$ is also special: the most frequent observation is called the *mode*.) Now work through an intuitive example with $N=24$ data points (hint: split the ordered observations into groups of six).

```{r}
X <-  c(3.1, 3, 0.02)
quantile(X, probs=c(0,.5,1))

# quantiles
X <- USArrests[,'Murder']
quantile(X)

# deciles are quantiles
quantile(X, probs=seq(0,1, by=.1))
```

To actually calculate quantiles, we sort the observations from smallest to largest as $X_{(1)}, X_{(2)},... X_{(N)}$, and then compute quantiles as $X_{ (q*N) }$. Note that $(q*N)$ is rounded and there are different ways to break ties.
```{r}
X <- USArrests[,'Murder']
Xo <- sort(X)
Xo

# median
Xo[length(Xo)*.5]
quantile(X, probs=.5, type=4)

# min
Xo[1]
min(Xo)
quantile(Xo, probs=0)
```

The boxplot shows the median (solid black line) and interquartile range ($IQR=$ upper quartile $-$ lower quartile; filled box).^[Technically, the upper and lower *hinges* use two different versions of the first and third quartile. See <https://stackoverflow.com/questions/40634693/lower-and-upper-quartiles-in-boxplot-in-r>.] As a default, whiskers are shown as $1.5\times IQR$ and values beyond that are highlighted as outliers---so whiskers do not typically show the data range. You can alternatively show all the raw data points instead of whisker+outliers.

```{r}
boxplot(USArrests[,'Murder'],
    main='', ylab='Murder Arrests',
    whisklty=0, staplelty=0, outline=F)
# Raw Observations
stripchart(USArrests[,'Murder'],
    pch='-', col=grey(0,.5), cex=2,
    vert=T, add=T)
```


