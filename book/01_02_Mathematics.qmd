
# Mathematics
***



## Objects

In R: scalars, vectors, and matrices are different kinds of "objects". 

These objects are used extensively in data analysis

* *scalars*: summary statistics (average household income).
* *vectors*: single variables in data sets (the household income of each family in Vancouver).
* *matrices*: two variables in data sets (the age and education level of every person in class).


Vectors are probably your most common object in R, but we will start with scalars.


#### **Scalars**. {-}

Make your first scalar
```{r}
xs <- 2 # Make your first scalar
xs  # Print the scalar
```

Perform simple calculations and see how R is doing the math for you
```{r}
xs + 2
xs*2 # Perform and print a simple calculation
(xs+1)^2 # Perform and print a simple calculation
xs + NA # often used for missing values
```

Now change `xs`, predict what will happen, then re-run the code.

#### **Vectors**. {-}

Make your first vector
```{r}
x <- c(0,1,3,10,6) # Your First Vector
x # Print the vector
x[2] # Print the 2nd Element; 1
x+2 # Print simple calculation; 2,3,5,8,12
x*2
x^2
```

Apply mathematical calculations elementwise
```{r}
x+x
x*x
x^x
```

In R, scalars are treated as a vector with one element.
```{r}
c(1)
```

Sometimes, we will use vectors that are entirely ordered. 
```{r}
1:7
seq(0,1,by=.1)

# Ordering data
sort(x)
x[order(x)]
```


#### **Matrices**. {-}

Matrices are also common objects
```{r}
x1 <- c(1,4,9)
x2 <- c(3,0,2)
x_mat <- rbind(x1, x2)

x_mat       # Print full matrix
x_mat[2,]   # Print Second Row
x_mat[,2]   # Print Second Column
x_mat[2,2]  # Print Element in Second Column and Second Row
```

There are elementwise calculations
```{r}
x_mat+2
x_mat*2
x_mat^2

x_mat + x_mat
x_mat*x_mat #NOT classical matrix multiplication
x_mat^x_mat
```


And you can also use matrix algebra
```{r}
x_mat1 <- matrix(2:7,2,3)
x_mat1

x_mat2 <- matrix(4:-1,2,3)
x_mat2

tcrossprod(x_mat1, x_mat2) #x_mat1 %*% t(x_mat2)

crossprod(x_mat1, x_mat2)
```


##  Functions

#### **Basic Functions**. {-}

Functions are applied to objects
```{r}
# Define a function that adds two to any vector
add_two <- function(input_vector) { #input_vector is a placeholder
    output_vector <- input_vector + 2 # new object defined locally 
    return(output_vector) # return new object 
}
# Apply that function to a vector
x <- c(0,1,3,10,6)
add_two(input_vector=x) #same as add_two(x)
```

Common mistakes:
```{r, eval=F}
print(output_vector)
# This is not available globally

# Double check your spelling
x < - add_two(input_vector=X) 

# Seeing "+" in the bottom console
# often means you forgot to close the function with "}" 
# press "Escape" and try again
add_two <- function(input_vector) { 
    output_vector <- input_vector + 2 
    return(output_vector)
x <- c(0,1,3,10,6)
add_two(x)
```

There are many many generalizations
```{r}
add_vec <- function(input_vector1, input_vector2) {
    output_vector <- input_vector1 + input_vector2
    return(output_vector)
}
add_vec(x,3)
add_vec(x,x)

sum_squared <- function(x1, x2) {
    y <- (x1 + x2)^2
    return(y)
}

sum_squared(1, 3)
sum_squared(x, 2)
sum_squared(x, NA) 
sum_squared(x, x)
sum_squared(x, 2*x)
```

Functions can take functions as arguments. Note that a *statistic* is defined as a function of data.
```{r}
statistic <- function(x,f){
    y <- f(x)
    return(y)
}
statistic(x, sum)
```


You can apply functions to matrices
```{r}
sum_squared(x_mat, x_mat)

# Apply function to each matrix row
y <- apply(x_mat, 1, sum)^2 
# ?apply  #checks the function details
y - sum_squared(x, x) # tests if there are any differences
```

There are many possible functions you can make and use
```{r}
fun_of_seq <- function(f){
    x1 <- seq(1,3, length.out=12)
    x2 <- x1+2
    x <- cbind(x1,x2)
    y <- f(x)
    return(y)
}
fun_of_seq(sum)
fun_of_seq(prod)
```


#### **Loops**. {-}

Applying the same function over and over again
```{r}
#Create empty vector
exp_vector <- vector(length=3)
#Fill empty vector
for(i in 1:3){
    exp_vector[i] <- exp(i)
}

# Compare
exp_vector
c( exp(1), exp(2), exp(3))
```

A more complicated example
```{r}
complicated_fun <- function(i, j=0){
    x <- i^(i-1)
    y <- x + mean( j:i )
    z <- log(y)/i
    return(z)
}
complicated_vector <- vector(length=10)
for(i in 1:10){
    complicated_vector[i] <- complicated_fun(i)
}
```

A recursive example
```{r}
x <- vector(length=4)
x[1] <- 1
for(i in 2:4){
    x[i] <- (x[i-1]+1)^2
}
x
```

<!---
```{r, eval=F, echo=F}
# mapply takes multiple vectors
# mapply(sum, 1:3, exp(1:3) )
```

```{r}
# for loop in a function
r_fun <- function(n){
    x <- rep(1,n)
    for(i in 2:length(x) ){
        x[i] <- (x[i-1]+1)^2
    }
    return(x)
}
r_fun(5)
```
--->


## Logic and Counting

#### **Basic Logic**. {-}

TRUE/FALSE
```{r}
x <- c(1,2,3,NA)
x > 2
x==2

any(x==2)
all(x==2)
2 %in% x

2==TRUE
2==FALSE
 
is.numeric(x)
is.na(x)
```

The "&" and "|" commands are logical calculations that compare vectors to the left and right.
```{r}
x <- 1:3
(x >= 1) & (x < 2)
(x >= 1) | (x < 2)

if( all(x >= 1) ){
    print("ok")
} else {
    print("not ok")
}

logic_fun <- function(x){
    if( all(x >= 1) ){
        print("ok")
    } else {
        print("not ok")
    }
}
logic_fun(1:3)
logic_fun(0:2)
```


#### **Basic Counting**. {-}

Factorials are used for counting the different ways of arranging $n$ distinct objects into a sequence: $n!=1\times2\times3 ... (n-2)\times(n-1)\times n$.
```{r}
factorial(3)
```

:::{.callout-note icon=false collapse="true"}
How many ways are there to order the numbers 1, 2, 3?

{1,2,3} {1,3,2}  
{2,1,3} {2,3,1}  
{3,2,1} {3,1,2}
:::

The binomial coefficient $\tbinom {n}{k}$ counts the subsets of $k$ elements from a set with $n$ elements.
```{r}
#Ways to draw k=2 from a set with n=4 
choose(4,2)
```

:::{.callout-note icon=false collapse="true"}
How many subsets with k=2 are there for the set {1,2,3,4}

{1,2} {1,3}, {3,4}  
{2,3} {2,4}  
{3,4}  
:::

The exponential function is $e^{x}=1+x/1+2^2/2+x^3/6....=\sum_{k=0}^{\infty} x^k/k!$ and the $log$ function is it's inverse.
```{r}
x <- exp(4)
x

y <- log(x)
y
```


