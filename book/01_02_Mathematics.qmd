
# Mathematics
***



## Objects

In R: scalars, vectors, and matrices are different kinds of "objects". 

These objects are used extensively in data analysis

* scalars: summary statistics (average household income).
* vectors: single variables in data sets (the household income of each family in Vancouver).
* matrices: multiple variables in data sets (the age and education level of every person in class).


Vectors are probably your most common object in R, but we will start with scalars (which are treated as a special case in R).


#### **Scalars**. {-}

Make your first scalar
```{r}
xs <- 2 # Make your first scalar
xs  # Print the scalar
```

Perform simple calculations and see how R is doing the math for you
```{r}
xs + 2
xs*2 # Perform and print a simple calculation
(xs+1)^2 # Perform and print a simple calculation
xs + NA # often used for missing values
```

Now change `xs`, predict what will happen, then re-run the code.

#### **Vectors**. {-}

Make Your First Vector
```{r}
x <- c(0,1,3,10,6) # Your First Vector
x # Print the vector
x[2] # Print the 2nd Element; 1
x+2 # Print simple calculation; 2,3,5,8,12
x*2
x^2
```

Apply Mathematical calculations "elementwise"
```{r}
x+x
x*x
x^x
```

See that scalars are vectors
```{r}
c(1)

1:7
seq(0,1,by=.1)
```


#### **Matrices**. {-}

Matrices are also common objects
```{r}
x1 <- c(1,4,9)
x2 <- c(3,0,2)
x_mat <- rbind(x1, x2)

x_mat       # Print full matrix
x_mat[2,]   # Print Second Row
x_mat[,2]   # Print Second Column
x_mat[2,2]  # Print Element in Second Column and Second Row
```

There are elementwise calculations
```{r}
x_mat+2
x_mat*2
x_mat^2

x_mat + x_mat
x_mat*x_mat
x_mat^x_mat
```

And you can also use matrix algebra
```{r}
x_mat1 <- matrix(2:7,2,3)
x_mat1

x_mat2 <- matrix(4:-1,2,3)
x_mat2

tcrossprod(x_mat1, x_mat2) #x_mat1 %*% t(x_mat2)

crossprod(x_mat1, x_mat2)
# x_mat1 * x_mat2
```


##  Functions

Functions are applied to objects
```{r}
# Define a function that adds two to any vector
add_2 <- function(input_vector) {
    output_vector <- input_vector + 2 # new object defined locally 
    return(output_vector) # return new object 
}
# Apply that function to a vector
x <- c(0,1,3,10,6)
add_2(x)

# notice 'output_vector' is not available here
```

There are many many generalizations
```{r}
add_vec <- function(input_vector1, input_vector2) {
    output_vector <- input_vector1 + input_vector2
    return(output_vector)
}
add_vec(x,3)
add_vec(x,x)

sum_squared <- function(x1, x2) {
    y <- (x1 + x2)^2
    return(y)
}

sum_squared(1, 3)
sum_squared(x, 2)
sum_squared(x, NA) 
sum_squared(x, x)
sum_squared(x, 2*x)
```

Functions can take functions as arguments
```{r}
fun_of_seq <- function(f){
    x <- seq(1,3, length.out=12)
    y <- f(x)
    return(y)
}

fun_of_seq(mean)

fun_of_seq(sd)
```

You can apply functions to matrices
```{r}
sum_squared(x_mat, x_mat)

# Apply function to each matrix row
y <- apply(x_mat, 1, sum)^2 
# ?apply  #checks the function details
y - sum_squared(x, x) # tests if there are any differences
```

There are many possible functions you can apply
```{r}
# Return Y-value with minimum absolute difference from 3
abs_diff_y <- abs( y - 3 ) 
abs_diff_y # is this the luckiest number?

#min(abs_diff_y)
#which.min(abs_diff_y)
y[ which.min(abs_diff_y) ]
```

There are also some useful built in functions
```{r}
m <- matrix(c(1:3,2*(1:3)),byrow=TRUE,ncol=3)
m

# normalize rows
m/rowSums(m)

# normalize columns
t(t(m)/colSums(m))

# de-mean rows
sweep(m,1,rowMeans(m), '-')

# de-mean columns
sweep(m,2,colMeans(m), '-')
```


#### **Loops**. {-}

Applying the same function over and over again
```{r}
exp_vector <- vector(length=3)
for(i in 1:3){
    exp_vector[i] <- exp(i)
}

# Compare
exp_vector
c( exp(1), exp(2), exp(3))
```

store complicated example
```{r}
complicate_fun <- function(i, j=0){
    x <- i^(i-1)
    y <- x + mean( j:i )
    z <- log(y)/i
    return(z)
}
complicated_vector <- vector(length=10)
for(i in 1:10){
    complicated_vector[i] <- complicate_fun(i)
}
```

recursive loop
```{r}
x <- vector(length=4)
x[1] <- 1
for(i in 2:4){
    x[i] <- (x[i-1]+1)^2
}
x
```

<!---
```{r, eval=F, echo=F}
# mapply takes multiple vectors
# mapply(sum, 1:3, exp(1:3) )
```

```{r}
# for loop in a function
r_fun <- function(n){
    x <- rep(1,n)
    for(i in 2:length(x) ){
        x[i] <- (x[i-1]+1)^2
    }
    return(x)
}
r_fun(5)
```
--->


#### **Logic**. {-}

Basic Logic

```{r}
x <- c(1,2,3,NA)
x > 2
x==2

any(x==2)
all(x==2)
2 %in% x

is.numeric(x)
is.na(x)
```

The "&" and "|" commands are logical calculations that compare vectors to the left and right.
```{r}
x <- 1:3
is.numeric(x) & (x < 2)
is.numeric(x) | (x < 2)

if(length(x) >= 5 & x[5] > 12) print("ok")
```

Advanced Logic.

```{r}
x <- 1:10
cut(x, 4)
split(x, cut(x, 4))
```

```{r}
xs <- split(x, cut(x, 4))
sapply(xs, mean)

# shortcut
aggregate(x, list(cut(x,4)), mean)
```

see https://bookdown.org/rwnahhas/IntroToR/logical.html


## Arrays

Arrays are generalization of matrices. They are often used in spatial econometrics, and are a very efficient way to store numeric data with the same dimensions.

```{r}
a <- array(data = 1:24, dim = c(2, 3, 4))
```

```{r, eval=F}
a

a[1, , , drop = FALSE]  # Row 1
#a[, 1, , drop = FALSE]  # Column 1
#a[, , 1, drop = FALSE]  # Layer 1

a[ 1, 1,  ]  # Row 1, column 1
#a[ 1,  , 1]  # Row 1, "layer" 1
#a[  , 1, 1]  # Column 1, "layer" 1
a[1 , 1, 1]  # Row 1, column 1, "layer" 1
```

Apply extends to arrays
```{r}
apply(a, 1, mean)    # Row means
apply(a, 2, mean)    # Column means
apply(a, 3, mean)    # "Layer" means
apply(a, 1:2, mean)  # Row/Column combination 
```

Outer products yield arrays
```{r}
x <- c(1,2,3)
x_mat1 <- outer(x, x) # x %o% x
x_mat1
is.array(x_mat) # Matrices are arrays

x_mat2 <- matrix(6:1,2,3)
outer(x_mat2, x)
# outer(x_mat2, matrix(x))
# outer(x_mat2, t(x))
# outer(x_mat1, x_mat2)
```
