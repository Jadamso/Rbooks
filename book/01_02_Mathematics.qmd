
# Mathematics
***



## Objects

In R: scalars, vectors, and matrices are different kinds of "objects". 

These objects are used extensively in data analysis

* *scalars*: summary statistics (average household income).
* *vectors*: single variables in data sets (the household income of each family in Vancouver).
* *matrices*: two variables in data sets (the age and education level of every person in class).


Vectors are probably your most common object in R, but we will start with scalars.


#### **Scalars**. {-}

Make your first scalar
```{r}
xs <- 2 # Make your first scalar
xs  # Print the scalar
```

Perform simple calculations and see how R is doing the math for you
```{r}
xs + 2
xs*2 # Perform and print a simple calculation
(xs+1)^2 # Perform and print a simple calculation
xs + NA # often used for missing values
```

Now change `xs`, predict what will happen, then re-run the code.

#### **Vectors**. {-}

Make Your First Vector
```{r}
x <- c(0,1,3,10,6) # Your First Vector
x # Print the vector
x[2] # Print the 2nd Element; 1
x+2 # Print simple calculation; 2,3,5,8,12
x*2
x^2
```

Apply mathematical calculations elementwise
```{r}
x+x
x*x
x^x
```

In R, scalars are treated as a vector with one element.
```{r}
c(1)
```

Sometimes, we will use vectors that are entirely ordered. 
```{r}
1:7
seq(0,1,by=.1)

# Ordering data
sort(x)
x[order(x)]
```


#### **Matrices**. {-}

Matrices are also common objects
```{r}
x1 <- c(1,4,9)
x2 <- c(3,0,2)
x_mat <- rbind(x1, x2)

x_mat       # Print full matrix
x_mat[2,]   # Print Second Row
x_mat[,2]   # Print Second Column
x_mat[2,2]  # Print Element in Second Column and Second Row
```

There are elementwise calculations
```{r}
x_mat+2
x_mat*2
x_mat^2

x_mat + x_mat
x_mat*x_mat #NOT classical matrix multiplication
x_mat^x_mat
```


And you can also use matrix algebra
```{r}
x_mat1 <- matrix(2:7,2,3)
x_mat1

x_mat2 <- matrix(4:-1,2,3)
x_mat2

tcrossprod(x_mat1, x_mat2) #x_mat1 %*% t(x_mat2)

crossprod(x_mat1, x_mat2)
```


##  Functions

#### **Basic Functions**. {-}

Functions are applied to objects
```{r}
# Define a function that adds two to any vector
add_two <- function(input_vector) { #input_vector is a placeholder
    output_vector <- input_vector + 2 # new object defined locally 
    return(output_vector) # return new object 
}
# Apply that function to a vector
x <- c(0,1,3,10,6)
add_two(input_vector=x) #same as add_two(x)
```

Common mistakes:
```{r, eval=F}
print(output_vector)
# This is not available globally

# Seeing "+ add_2(x)" in the bottom console
# means you forgot to close the function with "}" 
# press "Escape" and try again

# Double check your spelling
```

There are many many generalizations
```{r}
add_vec <- function(input_vector1, input_vector2) {
    output_vector <- input_vector1 + input_vector2
    return(output_vector)
}
add_vec(x,3)
add_vec(x,x)

sum_squared <- function(x1, x2) {
    y <- (x1 + x2)^2
    return(y)
}

sum_squared(1, 3)
sum_squared(x, 2)
sum_squared(x, NA) 
sum_squared(x, x)
sum_squared(x, 2*x)
```

Functions can take functions as arguments. Note that a *statistic* is defined as a function of data.
```{r}
statistic <- function(x,f){
    y <- f(x)
    return(y)
}
statistic(x, mean)
```


You can apply functions to matrices
```{r}
sum_squared(x_mat, x_mat)

# Apply function to each matrix row
y <- apply(x_mat, 1, sum)^2 
# ?apply  #checks the function details
y - sum_squared(x, x) # tests if there are any differences
```


#### **Advanced Functions**. {-}

There are many possible functions you can apply
```{r}
# Return Y-value with minimum absolute difference from 3
abs_diff_y <- abs( y - 3 ) 
abs_diff_y # is this the luckiest number?

#min(abs_diff_y)
#which.min(abs_diff_y)
y[ which.min(abs_diff_y) ]
```

```{r}
fun_of_seq <- function(f){
    x1 <- seq(1,3, length.out=12)
    x2 <- x1+2
    x <- cbind(x1,x2)
    y <- f(x)
    return(y)
}
fun_of_seq(mean)
fun_of_seq(sd)
```


There are also some useful built in functions
```{r}
m <- matrix(c(1:3,2*(1:3)),byrow=TRUE,ncol=3)
m

# normalize rows
m/rowSums(m)

# normalize columns
t(t(m)/colSums(m))

# de-mean rows
sweep(m,1,rowMeans(m), '-')

# de-mean columns
sweep(m,2,colMeans(m), '-')
```


#### **Loops**. {-}

Applying the same function over and over again
```{r}
#Create empty vector
exp_vector <- vector(length=3)
#Fill empty vector
for(i in 1:3){
    exp_vector[i] <- exp(i)
}

# Compare
exp_vector
c( exp(1), exp(2), exp(3))
```

A more complicated example
```{r}
complicated_fun <- function(i, j=0){
    x <- i^(i-1)
    y <- x + mean( j:i )
    z <- log(y)/i
    return(z)
}
complicated_vector <- vector(length=10)
for(i in 1:10){
    complicated_vector[i] <- complicated_fun(i)
}
```

A recursive example
```{r}
x <- vector(length=4)
x[1] <- 1
for(i in 2:4){
    x[i] <- (x[i-1]+1)^2
}
x
```

<!---
```{r, eval=F, echo=F}
# mapply takes multiple vectors
# mapply(sum, 1:3, exp(1:3) )
```

```{r}
# for loop in a function
r_fun <- function(n){
    x <- rep(1,n)
    for(i in 2:length(x) ){
        x[i] <- (x[i-1]+1)^2
    }
    return(x)
}
r_fun(5)
```
--->


## Special Functions

#### **Basic Logic**. {-}

TRUE/FALSE
```{r}
x <- c(1,2,3,NA)
x > 2
x==2

any(x==2)
all(x==2)
2 %in% x

2==TRUE
2==FALSE
 
is.numeric(x)
is.na(x)
```

The "&" and "|" commands are logical calculations that compare vectors to the left and right.
```{r}
x <- 1:3
is.numeric(x) & (x < 2)
is.numeric(x) | (x < 2)

if(length(x) >= 5 & x[5] > 12) print("ok")
```

#### **Basic Counting**. {-}

```{r}
factorial(4)

choose(4,2)
```

#### **Advanced Logic**. {-}

```{r}
x <- 1:10
cut(x, 4)
split(x, cut(x, 4))
```

```{r}
xs <- split(x, cut(x, 4))
sapply(xs, mean)

# shortcut
aggregate(x, list(cut(x,4)), mean)
```

See <https://bookdown.org/rwnahhas/IntroToR/logical.html>



