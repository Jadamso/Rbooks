{
  "hash": "d9c9cf41e66fe0fad3cf76cf0ecb6188",
  "result": {
    "engine": "knitr",
    "markdown": "\n# First Steps\n***\n\n## Why Program in R?\n\nYou should program your statistical analysis, and we will cover some of the basics of how to do this in R. You also want your work to be replicable\n\n* *Replicable*: someone collecting new data comes to the same results.\n* *Reproducibile*: someone reusing your data comes to the same results.\n\nYou can read more about the distinction in many places, including\n\n* <https://www.annualreviews.org/doi/10.1146/annurev-psych-020821-114157>\n* <https://nceas.github.io/sasap-training/materials/reproducible_research_in_r_fairbanks/>\n\nWe focus on R because it is good for complex stats, concise figures, and coherent organization. It is built and developed by applied statisticians for statistics, and used by many in academia and industry. For students, think about labor demand and what may be good for getting a job. Do some of your own research to best understand how much to invest.\n\n\nMy main sell to you is that being reproducible is in your own self-interest.\n\n#### **An example workflow**. {-}\n\n***First Steps...***\n\n*Step 1*:  Some ideas and data about how variable $X_{1}$ affects variable $Y_{1}$, which we denote as $X_{1}\\to Y_{1}$\n\n* You copy some data into a spreadsheet, manually aggregate\n* do some calculations and tables the same spreadsheet\n* some other analysis from here and there, using this software and that.\n\n*Step 2*:  Pursuing the lead for a week or two\n\n* you extend your dataset with more observations\n* copy in a spreadsheet data, manually aggregate\n* do some more calculations and tables, same as before\n\n***A Little Way Down the Road ...***\n\n1 month later: someone asks about another factor: $X_{2} \\to Y$.\n\n* you download some other type of data\n* You repeat <u>Step 2</u> with some data on $X_{2}$.\n* The details from your \"point and click\" method are a bit fuzzy.\n* It takes a little time, but you successfully redo the analysis.\n\n4 months later: someone asks about yet another factor: $X_{3}\\to Y_{1}$.\n\n* You again repeat <u>Step 2</u> with some data on $X_{3}$.\n* You're pretty sure none of tables your tried messed up the order of the rows or columns.\n* It takes more time and effort. The data processing was not transparent, but you eventually redo the analysis.\n\n6 months later: you want to explore another outcome: $X_{2} \\to Y_{2}$.\n\n* You found out Excel had some bugs in it's statistical calculations (see e.g., <https://biostat.app.vumc.org/wiki/pub/Main/TheresaScott/StatsInExcel.TAScot.handout.pdf>). You now use a new version of the spreadsheet\n* You're not sure you merged everything correctly. After much time and effort, most (but not all) of the numbers match exactly.\n\n2 years later: your boss wants you to replicate your work: $X_{1}, X_{2}, X_{3} \\to Y_{1}$.\n\n* A rival has proposed something new. Their idea doesn't actually make any sense, but their figures and statistics look better.\n* You don't even use that computer anymore and a collaborator who handled the data on $X_{2}$ has moved on.\n\n\n#### **An alternative workflow**. {-}\n\nSuppose you decided to code what you did beginning with Step 2.\n\nIt does not take much time to update or replicate your results.\n\n* Your computer runs for 2 hours and reproduces the figures and tables.\n* You also rewrote your big calculations to use multiple cores, this took two hours to do but saved 6 hours *each time* you rerun your code.\n* You add some more data. It adds almost no time to see whether much has changed.\n\nYour results are transparent and easier to build on.\n\n* You see the exact steps you took and found an error\n  * Google *\"worst Excel errors\"* and note the frequency they arise from copy/paste via the \"point-and-click\" approach. E.g., *Fidelity's $2.6 Billion Dividend Error*.\n    * Glad you found a problem before sending your research out! See <https://retractionwatch.com/> and <https://econjwatch.org/>. Future economists should also read <https://core.ac.uk/download/pdf/300464894.pdf>.\n* You try out a new plot you found in *The Visual Display of Quantitative Information*, by Edward Tufte.\n  * It's not a standard plot, but google answers most of your questions.\n  * Tutorials help avoid bad practices, such as plotting 2D data as a 3D object (see e.g., <https://clauswilke.com/dataviz/no-3d.html>).\n* You try out an obscure statistical approach that's hot in your field.\n  * it doesn't make the report, but you have some confidence that candidate issue isn't a big problem\n\n\n## First Steps\n\n#### **Install R**. {-}\n\nFirst Install [R](https://cloud.r-project.org/).\nThen Install [Rstudio](https://www.rstudio.com/products/rstudio/download/).\n\n\nFor Fedora (linux) users, note that you need to first enable the repo and then install\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nsudo dnf install 'dnf-command(copr)'\nsudo dnf copr enable iucar/rstudio\nsudo dnf install rstudio-desktop\n```\n:::\n\n\n\n*Make sure you have the latest version of R and Rstudio for class.* If not, then reinstall. \n\n#### **Interfacing with R Studio**. {-}\n\nRstudio is perhaps the easiest to get going with. (There are other GUI's.)\n\nIn Rstudio, there are 4 panes. (If you do not see 4, click \"file > new file > R script\" on the top left of the toolbar.)\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](../Templates/Figures_Manual/Rstudio.svg)\n:::\n:::\n\n\nThe top left pane is where you write your code. For example, type\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n1+1\n```\n:::\n\n\nThe pane below is where your code is executed. \nKeep you mouse on the same line as your code, and then click \"Run\". \nYou should see\n```\n> 1+1\n[1] 2\n```\nIf you click \"Run\" again, you should see that same output printed again.\n\nYou should add comments to your codes, and you do this with hashtags. For example\n```\n# This is my first comment!\n1+1 # The simplest calculation I could think of\n```\nYou can execute each line one-at-a-time. Or you can highlight them both, to take advantage of how R executes commands line-by-line.\n\n#### **Reading This Textbook**. {-}\n\nAs we proceed, you can see both my source code and output like this:\n\n::: {.cell}\n\n```{.r .cell-code}\n1+1\n## [1] 2\n```\n:::\n\n\nThere are also special boxes\n\n:::{.callout-note icon=false collapse=\"true\"}\nThis box contains *need to know* examples. Such as \n\n::: {.cell}\n\n```{.r .cell-code}\n1+1\n## [1] 2\n```\n:::\n\n:::\n\n:::{.callout-tip icon=false collapse=\"true\"}\nThis box contains *test yourself* examples and questions. Such as \n\n::: {.cell}\n\n```{.r .cell-code}\n2+7\n## [1] 9\n2/7\n## [1] 0.2857143\n```\n:::\n\n:::\n\n\n#### **Assignment**. {-}\n\nYou can create \"variables\" that store values. For example,\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1 # Make your first variable\nx + 1 # The simplest calculation I could think of\n## [1] 2\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 23 #Another example\nx + 1\n## [1] 24\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- x + 1 #Another example\ny\n## [1] 24\n```\n:::\n\n\nYour variables must be defined in order to use them. Otherwise you get an error. For example,\n\n::: {.cell}\n\n```{.r .cell-code}\nX +   1 # notice that R is sensitive to capitalization \n## Error: object 'X' not found\n```\n:::\n\n\nYour variable names do not matter technically, but they should be informative\n\n::: {.cell}\n\n```{.r .cell-code}\none <- 1 # good variable name\none\n## [1] 1\n\none <- 43 # bad variable name\none\n## [1] 43\n```\n:::\n\n\nGood names avoid confusion later\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 43\nx_plus_two <- x + 2 # better\nx_plus_two\n## [1] 45\n```\n:::\n\n\n#### **Scripting**. {-}\n\n* Create a folder on your computer to save your scripts\n* Save your `R Script` file as *My_First_Script.R* in your folder\n* Close Rstudio\n* Open your script and re-run it\n\nAs you work through the material, make sure to both execute and save your scripts. Add lots of commentary to your scripts. Name your scripts systematically.\n\nThere are often many ways to accomplish the same goal. You first scripts will be very basic and rough, but you can edit them later based on what you learn. And you can always ask R for help\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(x, 2) # x + 2\n?sum\n```\n:::\n\n\nWe write script in the top left so that we can edit common mistakes.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Mistake 1: using undefined objects\nY\n\n#  Mistake 2: spelling and spacing\nY < - 43\nY_plus_z <- Y + z\n\n# Mistake 3: half-completed code\nx + y + \nx_plus_y_plus_z <- x + y + z\n# Seeing \"+\" in the bottom console?\n# press \"Escape\" and try again\n```\n:::\n\n\n\n## Mathematical Objects\n\nIn R: scalars, vectors, and matrices are different kinds of \"objects\". \n\nThese objects are used extensively in data analysis\n\n* *scalars*: summary statistics (average household income).\n* *vectors*: single variables in data sets (the household income of each family in Vancouver).\n* *matrices*: two variables in data sets (the age and education level of every person in class).\n\n\nVectors are probably your most common object in R, but we will start with scalars.\n\n\n#### **Scalars**. {-}\n\nMake your first scalar\n\n::: {.cell}\n\n```{.r .cell-code}\nxs <- 2 # Make your first scalar\nxs  # Print the scalar\n## [1] 2\n```\n:::\n\n\nPerform simple calculations and see how R is doing the math for you\n\n::: {.cell}\n\n```{.r .cell-code}\nxs + 2\n## [1] 4\nxs*2 # Perform and print a simple calculation\n## [1] 4\n(xs+1)^2 # Perform and print a simple calculation\n## [1] 9\nxs + NA # often used for missing values\n## [1] NA\n```\n:::\n\n\nNow change `xs`, predict what will happen, then re-run the code.\n\n#### **Vectors**. {-}\n\nMake your first vector\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(0,1,3,10,6) # Your First Vector\nx # Print the vector\n## [1]  0  1  3 10  6\nx[2] # Print the 2nd Element; 1\n## [1] 1\nx+2 # Print simple calculation; 2,3,5,8,12\n## [1]  2  3  5 12  8\nx*2\n## [1]  0  2  6 20 12\nx^2\n## [1]   0   1   9 100  36\n```\n:::\n\n\nApply mathematical calculations elementwise\n\n::: {.cell}\n\n```{.r .cell-code}\nx+x\n## [1]  0  2  6 20 12\nx*x\n## [1]   0   1   9 100  36\nx^x\n## [1] 1.0000e+00 1.0000e+00 2.7000e+01 1.0000e+10 4.6656e+04\n```\n:::\n\n\nIn R, scalars are treated as a vector with one element.\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1)\n## [1] 1\n```\n:::\n\n\nSometimes, we will use vectors that are entirely ordered. \n\n::: {.cell}\n\n```{.r .cell-code}\nseq(1,7,by=1) #1:7\n## [1] 1 2 3 4 5 6 7\nseq(1,7,by=0.5)\n##  [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0\n\n# Ordering data\nsort(x)\n## [1]  0  1  3  6 10\nx[order(x)]\n## [1]  0  1  3  6 10\n```\n:::\n\n\n\n#### **Matrices**. {-}\n\nMatrices are also common objects\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- c(1,4,9)\nx2 <- c(3,0,2)\nx_mat <- rbind(x1, x2)\n\nx_mat       # Print full matrix\n##    [,1] [,2] [,3]\n## x1    1    4    9\n## x2    3    0    2\nx_mat[2,]   # Print Second Row\n## [1] 3 0 2\nx_mat[,2]   # Print Second Column\n## x1 x2 \n##  4  0\nx_mat[2,2]  # Print Element in Second Column and Second Row\n## x2 \n##  0\n```\n:::\n\n\nThere are elementwise calculations\n\n::: {.cell}\n\n```{.r .cell-code}\nx_mat+2\n##    [,1] [,2] [,3]\n## x1    3    6   11\n## x2    5    2    4\nx_mat*2\n##    [,1] [,2] [,3]\n## x1    2    8   18\n## x2    6    0    4\nx_mat^2\n##    [,1] [,2] [,3]\n## x1    1   16   81\n## x2    9    0    4\n\nx_mat + x_mat\n##    [,1] [,2] [,3]\n## x1    2    8   18\n## x2    6    0    4\nx_mat*x_mat #NOT classical matrix multiplication\n##    [,1] [,2] [,3]\n## x1    1   16   81\n## x2    9    0    4\nx_mat^x_mat\n##    [,1] [,2]      [,3]\n## x1    1  256 387420489\n## x2   27    1         4\n```\n:::\n\n\n\nAnd you can also use matrix algebra\n\n::: {.cell}\n\n```{.r .cell-code}\nx_mat1 <- matrix( seq(2,7), 2, 3)\nx_mat1\n##      [,1] [,2] [,3]\n## [1,]    2    4    6\n## [2,]    3    5    7\n\nx_mat2 <- matrix( seq(4,-1), 2, 3)\nx_mat2\n##      [,1] [,2] [,3]\n## [1,]    4    2    0\n## [2,]    3    1   -1\n\ntcrossprod(x_mat1, x_mat2) #x_mat1 %*% t(x_mat2)\n##      [,1] [,2]\n## [1,]   16    4\n## [2,]   22    7\n\ncrossprod(x_mat1, x_mat2)\n##      [,1] [,2] [,3]\n## [1,]   17    7   -3\n## [2,]   31   13   -5\n## [3,]   45   19   -7\n```\n:::\n\n\n\n## Mathematical Functions\n\n#### **Simple Functions**. {-}\n\nFunctions are applied to objects\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define a function that adds two to any vector\nadd_two <- function(input_vector) { #input_vector is a placeholder\n    output_vector <- input_vector + 2 # new object defined locally \n    return(output_vector) # return new object \n}\n# Apply that function to a vector\nx <- c(0,1,3,10,6)\nadd_two(input_vector=x) #same as add_two(x)\n## [1]  2  3  5 12  8\n```\n:::\n\n\nCommon mistakes:\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(output_vector)\n# This is not available globally\n\n# Double check your spelling\nx < - add_two(input_vector=X) \n\n# Seeing \"+\" in the bottom console\n# often means you forgot to close the function with \"}\" \n# press \"Escape\" and try again\nadd_two <- function(input_vector) { \n    output_vector <- input_vector + 2 \n    return(output_vector)\nx <- c(0,1,3,10,6)\nadd_two(x)\n```\n:::\n\n\nThere are many different functions\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_vec <- function(input_vector1, input_vector2) {\n    output_vector <- input_vector1 + input_vector2\n    return(output_vector)\n}\nadd_vec(x,3)\n## [1]  3  4  6 13  9\nadd_vec(x,x)\n## [1]  0  2  6 20 12\n\nsum_squared <- function(x1, x2) {\n    y <- (x1 + x2)^2\n    return(y)\n}\n\nsum_squared(1, 3)\n## [1] 16\nsum_squared(x, 2)\n## [1]   4   9  25 144  64\nsum_squared(x, NA) \n## [1] NA NA NA NA NA\nsum_squared(x, x)\n## [1]   0   4  36 400 144\nsum_squared(x, 2*x)\n## [1]   0   9  81 900 324\n```\n:::\n\n\n\nFunctions can take functions as arguments. Note that a *statistic* is defined as a function of data.\n\n::: {.cell}\n\n```{.r .cell-code}\nstatistic <- function(x, f){\n    y <- f(x)\n    return(y)\n}\nstatistic(x, sum)\n## [1] 20\n```\n:::\n\n\n\nThere are many possible functions you can make and use. More complicated functions often have defaults.\n\n::: {.cell}\n\n```{.r .cell-code}\nfun_of_seq <- function(f, constant=2){\n    x1 <- seq(1,3, length.out=12)\n    x2 <- x1+constant\n    x <- cbind(x1,x2)\n    y <- f(x)\n    return(y)\n}\nfun_of_seq(sum)\n## [1] 72\nfun_of_seq(sum, 3)\n## [1] 84\nfun_of_seq(prod)\n## [1] 30799645993\nfun_of_seq(prod, 3)\n## [1] 473621744988\n```\n:::\n\n\n\nYou can also apply functions to matrices\n\n::: {.cell}\n\n```{.r .cell-code}\nsum_squared(x_mat, x_mat)\n##    [,1] [,2] [,3]\n## x1    4   64  324\n## x2   36    0   16\n\n# Apply function to each matrix row\ny <- apply(x_mat, 1, sum)^2 \n# ?apply  #checks the function details\n```\n:::\n\n\n\n#### **Loops**. {-}\n\nApplying the same function over and over again\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example 1: simple division\nx <- vector(length=3)\n#Fill empty vector\nfor(i in seq(1,3)){\n    x[i] <- i/2\n}\nx\n## [1] 0.5 1.0 1.5\n# Compare\n\n# Example 2: exponential\n#Create empty vector\nx <- vector(length=3)\n#Fill empty vector\nfor(i in seq(1,3)){\n    x[i] <- exp(i)\n}\n# Compare\nx\n## [1]  2.718282  7.389056 20.085537\nc( exp(1), exp(2), exp(3))\n## [1]  2.718282  7.389056 20.085537\n\n# Example 3: using existing data\nx <- c(1,3,9,2)\ny <- vector(length=length(x))\nfor(i in seq_along(x) ){\n    y[i] <- x[i] + 1\n}\ny\n## [1]  2  4 10  3\n```\n:::\n\n\nA more complicated example\n\n::: {.cell}\n\n```{.r .cell-code}\ncomplicated_fun <- function(i, j=0){\n    x <- i^(i-1)\n    y <- x + mean( seq(j,i) )\n    z <- log(y)/i\n    return(z)\n}\ncomplicated_vector <- vector(length=10)\nfor(i in seq(1,10) ){\n    complicated_vector[i] <- complicated_fun(i)\n}\n```\n:::\n\n\nA recursive example\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- vector(length=4)\nx[1] <- 1\nfor(i in seq(2,4) ){\n    x[i] <- (x[i-1]+1)^2\n}\nx\n## [1]   1   4  25 676\n```\n:::\n\n\n<!---\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# for loop in a function\nr_fun <- function(n){\n    x <- rep(1,n)\n    for(i in seq(2,length(x)) ){\n        x[i] <- (x[i-1]+1)^2\n    }\n    return(x)\n}\nr_fun(5)\n## [1]      1      4     25    676 458329\n```\n:::\n\n--->\n\n\n#### **Basic Logic**. {-}\n\nTRUE/FALSE\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1,2,3,NA)\nx > 2\n## [1] FALSE FALSE  TRUE    NA\nx==2\n## [1] FALSE  TRUE FALSE    NA\n\nany(x==2)\n## [1] TRUE\nall(x==2)\n## [1] FALSE\n2 %in% x\n## [1] TRUE\n\n2==TRUE\n## [1] FALSE\n2==FALSE\n## [1] FALSE\n \nis.numeric(x)\n## [1] TRUE\nis.na(x)\n## [1] FALSE FALSE FALSE  TRUE\n```\n:::\n\n\nThe \"&\" and \"|\" commands are logical calculations that compare vectors to the left and right.\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- seq(1,3)\n(x >= 1) & (x < 2)\n## [1]  TRUE FALSE FALSE\n(x >= 1) | (x < 2)\n## [1] TRUE TRUE TRUE\n\nif( all(x >= 1) ){\n    print(\"ok\")\n} else {\n    print(\"not ok\")\n}\n## [1] \"ok\"\n\nlogic_fun <- function(x){\n    if( all(x >= 1) ){\n        print(\"ok\")\n    } else {\n        print(\"not ok\")\n    }\n}\nlogic_fun( seq(1,3) )\n## [1] \"ok\"\nlogic_fun( seq(0,2) )\n## [1] \"not ok\"\n```\n:::\n\n\n\n## Further Reading\n\nThere are many good and free programming materials online. For help setting up, see any of the following links\n\n* <https://learnr-examples.shinyapps.io/ex-setup-r/>\n* <https://rstudio-education.github.io/hopr/starting.html>\n* <https://a-little-book-of-r-for-bioinformatics.readthedocs.io/en/latest/src/installr.html>\n* <https://cran.r-project.org/doc/manuals/R-admin.html>\n* <https://courses.edx.org/courses/UTAustinX/UT.7.01x/3T2014/56c5437b88fa43cf828bff5371c6a924/>\n* <https://owi.usgs.gov/R/training-curriculum/installr/>\n* <https://www.earthdatascience.org/courses/earth-analytics/document-your-science/setup-r-rstudio/>\n\nThe most common tasks can be found <https://github.com/rstudio/cheatsheets/blob/main/rstudio-ide.pdf>\n\nSome of my programming examples originally come from <https://r4ds.had.co.nz/> and I recommend <https://intro2r.com>. \n\nI have also used online material from many places over the years, as there are many good yet free-online tutorials and courses specifically on R programming. See e.g., \n\n* <https://cran.r-project.org/doc/manuals/R-intro.html>\n* R Graphics Cookbook, 2nd edition. Winston Chang. 2021. <https://r-graphics.org/>\n* R for Data Science. H. Wickham and G. Grolemund. 2017. <https://r4ds.had.co.nz/index.html>\n* An Introduction to R. W. N. Venables, D. M. Smith, R Core Team. 2017. <https://colinfay.me/intro-to-r/>\n* Introduction to R for Econometrics. Kieran Marray. <https://bookdown.org/kieranmarray/intro_to_r_for_econometrics/>\n* Wollschläger, D. (2020). Grundlagen der Datenanalyse mit R: eine anwendungsorientierte Einführung. <http://www.dwoll.de/rexrepos/>\n* Spatial Data Science with R: Introduction to R. Robert J. Hijmans. 2021. <https://rspatial.org/intr/index.html>\n* <https://www.econometrics-with-r.org/1.2-a-very-short-introduction-to-r-and-rstudio.html>\n* <https://rafalab.github.io/dsbook/>\n* <https://moderndive.com/foreword.html>\n* <https://rstudio.cloud/learn/primers/1.2>\n* <https://cran.r-project.org/manuals.html>\n* <https://stats.idre.ucla.edu/stat/data/intro_r/intro_r_interactive_flat.html>\n* <https://cswr.nrhstat.org/app-r>\n\n\nFor more on why to program in R, see\n\n* <http://www.r-bloggers.com/the-reproducibility-crisis-in-science-and-prospects-for-r/>\n* <http://fmwww.bc.edu/GStat/docs/pointclick.html>\n* <https://github.com/qinwf/awesome-R\\#reproducible-research>\n* A Guide to Reproducible Code in Ecology and Evolution\n* <https://biostat.app.vumc.org/wiki/pub/Main/TheresaScott/ReproducibleResearch.TAScott.handout.pdf>\n",
    "supporting": [
      "01_01_FirstSteps_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}