{
  "hash": "1ef49c41a432c9021c9bc3c2301aeb8d",
  "result": {
    "engine": "knitr",
    "markdown": "# Multivariate Data II\n***\n\n## Coefficient Interpretation\n\nNotice that we have gotten pretty far without actually trying to meaningfully interpret regression coefficients. That is because the above procedure will always give us number, regardless as to whether the true data generating process is linear or not. So, to be cautious, we have been interpreting the regression outputs while being agnostic as to how the data are generated. We now consider a special situation where we know the data are generated according to a linear process and are only uncertain about the parameter values.\n\nIf the data generating process is truly linear then we have a famous result that lets us attach a simple interpretation of OLS coefficients as unbiased estimates of the effect of $X$.^[If you know matrix notation, then assume\n\\begin{eqnarray}\nY_{i} = X_{i} \\beta + \\epsilon_{i} &\\quad& \\mathbb{E}[\\epsilon_{i} | X_{i} ]=0.\n\\end{eqnarray}\nThen define the estimator and notice that it is unbiased\n\\begin{eqnarray}\n\\beta^{*} = (X'X)^{-1}X'Y = (X'X)^{-1}X'(X\\beta + \\epsilon) = \\beta + (X'X)^{-1}X'\\epsilon\\\\\n\\mathbb{E}\\left[ \\beta^{*} \\right] = \\mathbb{E}\\left[ (X'X)^{-1}X'Y \\right] = \\beta + (X'X)^{-1}\\mathbb{E}\\left[ X'\\epsilon \\right] = \\beta\n\\end{eqnarray}\n]\n\nFor example, generate a simulated dataset with $30$ observations and two exogenous variables. Assume the following relationship: $Y_{i} = \\beta_0 + \\beta_1 X_{i1} + \\beta_2 X_{i2} + \\epsilon_{i}$ where the variables and the error term are realizations of the following data generating processes:\n\n::: {.cell}\n\n```{.r .cell-code}\nN <- 30\nB <- c(10, 2, -1)\n\nx1 <- runif(N, 0, 5)\nx2 <- rbinom(N,1,.7)\nX <- cbind(1,x1,x2)\ne <- rnorm(N,0,3)\nY <- X%*%B + e\ndat <- data.frame(Y,X)\ncoef(lm(Y~x1+x2, data=dat))\n## (Intercept)          x1          x2 \n##    8.968789    2.651818   -1.014159\n```\n:::\n\n\nSimulate the distribution of coefficients under a correctly specified model. Interpret the average.\n\n::: {.cell}\n\n```{.r .cell-code}\nN <- 30\nB <- c(10, 2, -1)\n\nCoefs <- sapply(1:400, function(sim){\n    x1 <- runif(N, 0, 5)\n    x2 <- rbinom(N,1,.7)\n    X <- cbind(1,x1,x2)\n    e <- rnorm(N,0,3)\n    Y <- X%*%B + e\n    dat <- data.frame(Y,x1,x2)\n    coef(lm(Y~x1+x2, data=dat))\n})\n\npar(mfrow=c(1,2))\nfor(i in 2:3){\n    hist(Coefs[i,], xlab=bquote(beta[.(i)]), main='', border=NA)\n    abline(v=mean(Coefs[i,]), lwd=2)\n    abline(v=B[i], col=rgb(1,0,0))\n}\n```\n\n::: {.cell-output-display}\n![](03_02_InterprettingRegression_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n\nMany economic phenomena are nonlinear, even when including potential transforms of $Y$ and $X$. Sometimes the linear model may still be a good or even great approximation. But sometimes not, and it is hard to know ex-ante. Examine the distribution of coefficients under this mispecified model and try to interpret the average.\n\n::: {.cell}\n\n```{.r .cell-code}\nN <- 30\n\nCoefs <- sapply(1:600, function(sim){\n    x2 <- runif(N, 0, 5)\n    x3 <- rbinom(N,1,.7)\n    e <- rnorm(N,0,3)\n    Y <- 10*x3 + 2*log(x2)^x3 + e\n    dat <- data.frame(Y,x2,x3)\n    coef(lm(Y~x2+x3, data=dat))\n})\n\npar(mfrow=c(1,2))\nfor(i in 2:3){\n    hist(Coefs[i,],  xlab=bquote(beta[.(i)]), main='', border=NA)\n    abline(v=mean(Coefs[i,]), col=1, lwd=2)\n}\n```\n\n::: {.cell-output-display}\n![](03_02_InterprettingRegression_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nIn general, you can interpret your regression coefficients as \"adjusted correlations\". There are (many) tests for whether the relationships in your dataset are actually additively separable and linear.\n\n\n##  Diagnostics\n\nThere's little sense in getting great standard errors for a terrible model. Plotting your regression object a simple and easy step to help diagnose whether your model is in some way bad. We next go through what each of these figures show.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nreg <- lm(Murder~Assault+UrbanPop, data=USArrests)\npar(mfrow=c(2,2))\nplot(reg, pch=16, col=grey(0,.5))\n```\n\n::: {.cell-output-display}\n![](03_02_InterprettingRegression_files/figure-html/unnamed-chunk-4-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n#### **Outliers**. {-}\nThe first diagnostic plot examines outliers in terms the observed outcome $\\hat{Y}_i$ being far from its prediction $\\hat{y}_i$. You may be interested in such outliers because they can (but do not have to) unduly influence your estimates. \n\nThe third diagnostic plot examines another type of outlier, the observed explanatory variable $\\hat{X}_{i}$ is far from the others. A point has high *leverage* if the estimates change dramatically when you estimate the model without that data point.\n\n::: {.cell}\n\n```{.r .cell-code}\nN <- 40\nx <- c(25, runif(N-1,3,8))\ne <- rnorm(N,0,0.4)\ny <- 3 + 0.6*sqrt(x) + e\nplot(y~x, pch=16, col=grey(0,.5))\npoints(x[1],y[1], pch=16, col=rgb(1,0,0,.5))\n\nabline(lm(y~x), col=2, lty=2)\nabline(lm(y[-1]~x[-1]))\n```\n\n::: {.cell-output-display}\n![](03_02_InterprettingRegression_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nStandardized residuals are $r_i=\\frac{\\hat{e}_i}{s_{[i]}\\sqrt{1-h_i}}$, where $s_{[i]}$ is the root mean squared error of a regression with the $i$th observation removed and $h_i$ is the leverage of residual $\\hat{e}_{i}$. \n\n::: {.cell}\n\n```{.r .cell-code}\nwhich.max(hatvalues(reg))\nwhich.max(rstandard(reg))\n```\n:::\n\n\nThe fourth plot further assesses outliers in the explanatory variables ($X$) using *Cook's Distance*, which sums of all prediction changes when observation $i$ is removed and scales proportionally to the mean square error\n\\begin{eqnarray}\nD_{i} \n&=& \\frac{\\sum_{j} \\left( \\hat{y_j} - \\hat{y_j}_{[i]} \\right)^2 }{ p \\hat{S}^2 }\n= \\frac{\\hat{e}_{i}^2}{p \\hat{S}^2 } \\frac{h_i}{(1-h_i)^2} \\\\\n\\hat{S}^2 &=& \\frac{\\sum_{i} \\hat{e}_{i}^2 }{n-K}.\n\\end{eqnarray}\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich.max(cooks.distance(reg))\ncar::influencePlot(reg)\n```\n:::\n\n\n\nSee <https://www.r-bloggers.com/2016/06/leverage-and-influence-in-a-nutshell/> for a good interactive explanation, and <https://online.stat.psu.edu/stat462/node/87/> for detail. See [AEJ-leverage](https://www.rwi-essen.de/fileadmin/user_upload/RWI/Publikationen/I4R_Discussion_Paper_Series/032_I4R_Haddad_Kattan_Wochner-updateJune28.pdf) and [NBER-leverage](https://statmodeling.stat.columbia.edu/2025/02/28/the-r-squared-on-this-is-kinda-low-no/) for examples of leverage in economics.\n\n\n#### **Collinearity**. {-}\nThis is when one explanatory variable in a multiple linear regression model can be linearly predicted from the others with a substantial degree of accuracy. Coefficient estimates may change erratically in response to small changes in the model or the data. (In the extreme case, there are more variables than observations $K>n$ and an infinite number of solutions to a linear model.) To diagnose collinearity, we can use the *Variance Inflation Factor*: $\\hat{VIF}_{k}=\\frac{1}{1-\\hat{R}^2_k}$, where $\\hat{R}^2_k$ is the $\\hat{R}^2$ for the regression of $\\hat{X}_k$ on the other covariates $\\hat{X}_{-k}$ (a regression that does not involve the response variable $\\hat{Y}$)\n\n::: {.cell}\n\n```{.r .cell-code}\ncar::vif(reg) \nsqrt(car::vif(reg)) > 2 # problem?\n```\n:::\n\n\n\n#### **Normality**. {-}\nThe second plot examines whether the residuals are normally distributed. Your OLS coefficient estimates do not depend on the normality of the residuals. (Good thing, because there's no reason the residuals of economic phenomena should be so well behaved.) Many hypothesis tests are, however, affected by the distribution of the residuals. For these reasons, you may be interested in assessing normality \n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(1,2))\nhist(resid(reg),\n    main='Histogram of Residuals',\n    font.main=1, border=NA)\n\nqqnorm(resid(reg),\n    main=\"Normal Q-Q Plot of Residuals\",\n    font.main=1, col=grey(0,.5), pch=16)\nqqline(resid(reg), col=1, lty=2)\n\n#shapiro.test(resid(reg))\n```\n:::\n\n\nHeterskedasticity may also matters for variability estimates. This is not shown in the plot, but you can conduct a simple test\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lmtest)\nlmtest::bptest(reg)\n```\n:::\n\n\n## Transformations\n\nTransforming variables can often improve your model fit while still allowing it estimated via OLS. This is because OLS only requires the model to be linear in the parameters. Under the assumptions of the model is correctly specified, the following table is how we can interpret the coefficients of the transformed data. (Note for small changes, $\\Delta ln(x) \\approx \\Delta x / x = \\Delta x \\% \\cdot 100$.)\n\n| *Specification* | *Regressand* | *Regressor* | *Derivative* | *Interpretation (If True)* |\n| --- | --- | --- | --- | --- |\n| linear--linear | $y$          | $x$   | $\\Delta y = \\beta_1\\cdot\\Delta x$ | Change $x$ by one unit $\\rightarrow$ change $y$ by $\\beta_1$ units.|\n| log--linear | $ln(y)$ | $x$ | $\\Delta y \\% \\cdot 100 \\approx \\beta_1 \\cdot \\Delta x$ | Change $x$ by one unit $\\rightarrow$ change $y$ by $100 \\cdot \\beta_1$ percent. |\n| linear--log | $y$ | $ln(x)$ | $\\Delta y \\approx  \\frac{\\beta_1}{100}\\cdot \\Delta x \\%$ | Change $x$ by one percent $\\rightarrow$ change $y$ by $\\frac{\\beta_1}{100}$ units |\n| log--log | $ln(y)$ | $ln(x)$ | $\\Delta y \\% \\approx \\beta_1\\cdot \\Delta x \\%$ | Change $x$ by one percent $\\rightarrow$ change $y$ by $\\beta_1$ percent|\n\nNow recall from micro theory that an additively seperable and linear production function is referred to as ``perfect substitutes''. With a linear model and untranformed data, you have implicitly modelled the different regressors $X$ as perfect substitutes. Further recall that the ''perfect substitutes'' model is a special case of the constant elasticity of substitution production function. Here, we will build on <http://dx.doi.org/10.2139/ssrn.3917397>, and consider box-cox transforming both $X$ and $y$. Specifically, apply the box-cox transform of $y$ using parameter $\\lambda$ and apply another box-cox transform to each $x$ using the same parameter $\\rho$ so that\n\\begin{eqnarray}\nY^{(\\lambda)}_{i} &=& \\sum_{k=1}^{K}\\beta_{k} X^{(\\rho)}_{ik} + \\epsilon_{i}\\\\\nY^{(\\lambda)}_{i} &=&\n\\begin{cases}\n\\lambda^{-1}\\left[ (Y_i+1)^{\\lambda}- 1\\right] & \\lambda \\neq 0 \\\\\n\\log\\left(Y_i+1\\right) &  \\lambda=0\n\\end{cases}.\\\\\nx^{(\\rho)}_{i} &=&\n\\begin{cases}\n\\rho^{-1}\\left[ (X_i)^{\\rho}- 1\\right] & \\rho \\neq 0 \\\\\n\\log\\left(X_{i}+1\\right) &  \\rho=0\n\\end{cases}.\n\\end{eqnarray}\n\nNotice that this nests:\n\n * linear-linear $(\\rho=\\lambda=1)$.\n * linear-log $(\\rho=1, \\lambda=0)$.\n * log-linear $(\\rho=0, \\lambda=1)$.\n * log-log  $(\\rho=\\lambda=0)$.\n\n\nIf $\\rho=\\lambda$, we get the CES production function. This nests the ''perfect substitutes'' linear-linear model ($\\rho=\\lambda=1$) , the ''cobb-douglas''  log-log model  ($\\rho=\\lambda=0$), and many others. We can define $\\lambda=\\rho/\\lambda'$ to be clear that this is indeed a CES-type transformation where\n\n* $\\rho \\in (-\\infty,1]$ controls the \"substitutability\" of explanatory variables. E.g., $\\rho <0$ is ''complementary''.\n* $\\lambda$ determines ''returns to scale''. E.g., $\\lambda<1$ is ''decreasing returns''.\n\n\nWe compute the mean squared error in the original scale by inverting the predictions;\n\\begin{eqnarray}\n\\hat{y}_{i} =\n\\begin{cases}\n\\left[ \\hat{y}_{i}^{(\\lambda)} \\cdot \\lambda \\right]^{1/\\lambda} -1 & \\lambda  \\neq 0 \\\\\n\\exp\\left( \\hat{y}_{i}^{(\\lambda)} \\right) -1 &  \\lambda=0\n\\end{cases}.\n\\end{eqnarray}\n\n\nIt is easiest to optimize parameters in a 2-step procedure called  `concentrated optimization'. We first solve for $\\widehat{\\beta}(\\rho,\\lambda)$ and compute the mean squared error $MSE(\\rho,\\lambda)$. We then find the $(\\rho,\\lambda)$ which minimizes $MSE$.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Box-Cox Transformation Function\nbxcx <- function( xy, rho){\n    if (rho == 0L) {\n      log(xy+1)\n    } else if(rho == 1L){\n      xy\n    } else {\n      ((xy+1)^rho - 1)/rho\n    }\n}\nbxcx_inv <- function( xy, rho){\n    if (rho == 0L) {\n      exp(xy) - 1\n    } else if(rho == 1L){\n      xy\n    } else {\n     (xy * rho + 1)^(1/rho) - 1\n    }\n}\n\n# Which Variables\nreg <- lm(Murder~Assault+UrbanPop, data=USArrests)\nX <- USArrests[,c('Assault','UrbanPop')]\nY <- USArrests[,'Murder']\n\n# Simple Grid Search over potential (Rho,Lambda) \nrl_df <- expand.grid(rho=seq(-2,2,by=.5),lambda=seq(-2,2,by=.5))\n\n# Compute Mean Squared Error\n# from OLS on Transformed Data\nerrors <- apply(rl_df,1,function(rl){\n    Xr <- bxcx(X,rl[[1]])\n    Yr <- bxcx(Y,rl[[2]])\n    Datr <- cbind(Murder=Yr,Xr)\n    Regr <- lm(Murder~Assault+UrbanPop, data=Datr)\n    Predr <- bxcx_inv(predict(Regr),rl[[2]])\n    Resr  <- (Y - Predr)\n    return(Resr)\n})\nrl_df$mse <- colMeans(errors^2)\n\n# Want Small MSE and Interpretable\nlayout(matrix(1:2,ncol=2), width=c(3,1), height=c(1,1))\npar(mar=c(4,4,2,0))\nplot(lambda~rho,rl_df, cex=8, pch=15,\n    xlab=expression(rho),\n    ylab=expression(lambda),\n    col=hcl.colors(25)[cut(1/rl_df$mse,25)])\n# Which min\nrl0 <- rl_df[which.min(rl_df$mse),c('rho','lambda')]\npoints(rl0$rho, rl0$lambda, pch=0, col=1, cex=8, lwd=2)\n# Legend\nplot(c(0,2),c(0,1), type='n', axes=F,\n    xlab='',ylab='', cex.main=.8,\n    main=expression(frac(1,'Mean Square Error')))\nrasterImage(as.raster(matrix(hcl.colors(25), ncol=1)), 0, 0, 1,1)\ntext(x=1.5, y=seq(1,0,l=10), cex=.5,\n    labels=levels(cut(1/rl_df$mse,10)))\n```\n\n::: {.cell-output-display}\n![](03_02_InterprettingRegression_files/figure-html/unnamed-chunk-11-1.png){fig-align='center' width=960}\n:::\n:::\n\n\nThe parameters $-1,0,1,2$ are easy to interpret and might be selected instead if there is only a small loss in fit. (In the above example, we might choose $\\lambda=0$ instead of the $\\lambda$ which minimized the mean square error). You can also plot the specific predictions to better understand the effect of data  transformation beyond mean squared error.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot for Specific Comparisons\nXr <- bxcx(X,rl0[[1]])\nYr <- bxcx(Y,rl0[[2]])\nDatr <- cbind(Murder=Yr,Xr)\nRegr <- lm(Murder~Assault+UrbanPop, data=Datr)\nPredr <- bxcx_inv(predict(Regr),rl0[[2]])\n\ncols <- c(rgb(1,0,0,.5), col=rgb(0,0,1,.5))\nplot(Y, Predr, pch=16, col=cols[1], ylab='Prediction', \n    ylim=range(Y,Predr))\npoints(Y, predict(reg), pch=16, col=cols[2])\nlegend('topleft', pch=c(16), col=cols,\n    title=expression(rho~', '~lambda),\n    legend=c( paste0(rl0, collapse=', '),'1, 1') )\nabline(a=0,b=1, lty=2)\n```\n\n::: {.cell-output-display}\n![](03_02_InterprettingRegression_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nWhen explicitly transforming data according to $\\lambda$ and $\\rho$, these parameters increase the degrees of freedom by two. The default hypothesis testing procedures do not account for you trying out different transformations, and should be adjusted by the increased degrees of freedom. Specification searches deflate standard errors and are a major source for false discoveries.\n\nNote that if you are ultimately interested in the outcome $Y$, then transforming/untransforming $Y$ can introduce a bias. To understand when you might be better off sticking with an untransformed outcome variable, see the literature on \"smearing\".\n\n#### **Break Points**. {-}\nIncorporating Kinks and Discontinuities in $X$ are a type of transformation that can be modeled using factor variables. As such, $F$-tests can be used to examine whether a breaks is statistically significant.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(AER); data(CASchools)\nCASchools$score <- (CASchools$read + CASchools$math) / 2\nreg <- lm(score~income, data=CASchools)\n\n# F Test for Break\nreg2 <- lm(score ~ income*I(income>15), data=CASchools)\nanova(reg, reg2)\n\n# Chow Test for Break\ndata_splits <- split(CASchools, CASchools$income <= 15)\nresids <- sapply(data_splits, function(dat){\n    reg <- lm(score ~ income, data=dat)\n    sum( resid(reg)^2)\n})\nNs <-  sapply(data_splits, function(dat){ nrow(dat)})\nRt <- (sum(resid(reg)^2) - sum(resids))/sum(resids)\nRb <- (sum(Ns)-2*reg$rank)/reg$rank\nFt <- Rt*Rb\npf(Ft,reg$rank, sum(Ns)-2*reg$rank,lower.tail=F)\n\n# See also\n# strucchange::sctest(y~x, data=xy, type=\"Chow\", point=.5)\n# strucchange::Fstats(y~x, data=xy)\n\n# To Find Changes\n# segmented::segmented(reg)\n```\n:::\n\n\n\n## Regressograms\n\nYou can estimate a nonparametric model with multiple $X$ variables with a multivariate regressogram. Here, we cut the data into exclusive bins along each dimension (called dummy variables), and then run a regression on all dummy variables. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Simulate Data\nN <- 10000\ne <- rnorm(N)\nx1 <- seq(.1,20,length.out=N)\nx2 <- runif(N, 0,1)\ny  <- 3*exp(-2*x2 + 1.5*x1 - .1*x1^2)*x1 + e\ndat <- data.frame(x1, x2, y)\n\n## Create color palette (reused in later examples)\ncol_scale <- seq(min(y)*1.1, max(y)*1.1, length.out=401)\nycol_pal <- hcl.colors(length(col_scale),alpha=.5)\nnames(ycol_pal) <- sort(col_scale)\n\n## Add legend (reused in later examples)\nadd_legend <- function(col_scale,\n    yl=11,\n    colfun=function(x){ hcl.colors(x,alpha=.5) },\n    ...) {\n  opar <- par(fig=c(0, 1, 0, 1), oma=c(0, 0, 0, 0), \n              mar=c(0, 0, 0, 0), new=TRUE)\n  on.exit(par(opar))\n  h <- hist(col_scale, plot=F, breaks=yl-1)$mids\n  plot(0, 0, type='n', bty='n', xaxt='n', yaxt='n')\n  legend(...,\n    legend=h,\n    fill=colfun(length(h)),\n    border=NA,\n    bty='n')\n}\n\n\n## Plot Data\npar(oma=c(0,0,0,2))\nplot(x1~x2, dat,\n    col=ycol_pal[cut(y,col_scale)],\n    pch=16, cex=.5, \n    main='Raw Data', font.main=1)\nadd_legend(x='topright', col_scale=col_scale,\n    yl=6, inset=c(0,.05), title='y')\n```\n\n::: {.cell-output-display}\n![](03_02_InterprettingRegression_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## OLS \nreg <- lm(y~x1*x2, data=dat) #(with simple interaction)\nreg <- lm(y~x1+x2, data=dat) #(without interaction)\n\n## Grid Points for Prediction\n# X1 bins\nl1 <- 11\nbks1 <- seq(0,20, length.out=l1)\nh1 <- diff(bks1)[1]/2\nmids1 <- bks1[-1]-h1\n# X2 bins\nl2 <- 11\nbks2 <- seq(0,1, length.out=l2)\nh2 <- diff(bks2)[1]/2\nmids2 <- bks2[-1]-h2\n# Grid\npred_x <- expand.grid(x1=mids1, x2=mids2)\n\n## OLS Predictions\npred_ols <- predict(reg, newdata=pred_x)\npred_df_ols  <- cbind(pred_ols, pred_x)\n\n## Plot Predictions\npar(oma=c(0,0,0,2))\nplot(x1~x2, pred_df_ols,\n    col=ycol_pal[cut(pred_ols,col_scale)],\n    pch=15, cex=2,\n    main='OLS Predictions', font.main=1)\nadd_legend(x='topright', col_scale=col_scale,\n    yl=6, inset=c(0,.05),title='y')\n```\n\n::: {.cell-output-display}\n![](03_02_InterprettingRegression_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n##################\n# Multivariate Regressogram\n##################\n\n## Regressogram Bins\ndat$x1c <- cut(dat$x1, bks1)\n#head(dat$x1c,3)\ndat$x2c <- cut(dat$x2, bks2)\n\n## Regressogram\nreg <- lm(y~x1c*x2c, data=dat) #nonlinear w/ complex interactions\n\n## Predicted Values\n## For Points in Middle of Each Bin\npred_df_rgrm <- expand.grid(\n    x1c=levels(dat$x1c),\n    x2c=levels(dat$x2c))\npred_df_rgrm$yhat <- predict(reg, newdata=pred_df_rgrm)\npred_df_rgrm <- cbind(pred_df_rgrm, pred_x)\n\n## Plot Predictions\npar(oma=c(0,0,0,2))\nplot(x1~x2, pred_df_rgrm,\n    col=ycol_pal[cut(pred_df_rgrm$yhat,col_scale)],\n    pch=15, cex=2,\n    main='Regressogram Predictions', font.main=1)\nadd_legend(x='topright', col_scale=col_scale,\n    yl=6, inset=c(0,.05),title='y')\n```\n\n::: {.cell-output-display}\n![](03_02_InterprettingRegression_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\nJust like with bivariate data, you can also use split-sample (or peicewise) regressions for multivariate data.\n\nAs such, there are two main ways to summarize gradients: how $Y$ changes with $X$.\n\n1. For regressograms, you can approximate gradients with small finite differences. For some small $h_{p}$, we can compute\n\\begin{eqnarray}\n\\hat{\\beta}_{p}(\\mathbf{x}) &=& \\frac{ \\hat{y}(x_{1},...,x_{p}+ \\frac{h_{p}}{2}...,x_{P})-\\hat{y}(x_{1},...,x_{p}-\\frac{h_{p}}{2}...,x_{P})}{h_{p}},\n\\end{eqnarray}\n\n2. When using split-sample regressions or local linear regressions, you can use the estimated slope coefficients $\\hat{\\beta}_{p}(\\mathbf{x})$ as gradient estimates in each direction.^[In matrix notation, we have the estimates\n\\begin{eqnarray}\n\\hat{\\beta}(\\mathbf{x}) &=& [\\mathbf{X}'\\mathbf{K}(\\mathbf{x})\\mathbf{X}]^{-1} \\mathbf{X}'\\mathbf{K}(\\mathbf{x})Y \\\\\n\\mathbf{K}(\\mathbf{x}) &=& \\begin{pmatrix}\nK\\left(\\frac{\\mathbf{X}_{1}-\\mathbf{x}}{h_{1}}\\right) & ... & 0\\\\\n\\vdots & & \\\\\n0 & ... & K\\left(\\frac{\\mathbf{X}_{P}-\\mathbf{x}}{h_{P}}\\right)\n\\end{pmatrix}.\n\\end{eqnarray}\n]\n\nAfter computing gradients, you can summarize them in various plots:  Histogram of $\\hat{\\beta}_{p}(\\mathbf{x})$, Scatterplot of $\\hat{\\beta}_{p}(\\mathbf{x})$ vs. $X_{p}$, or the CI of $\\hat{\\beta}_{p}(\\mathbf{x})$ vs $\\hat{\\beta}_{p}(\\mathbf{x})$ after sorting the gradients \\cite{Chaudhuri1999, HendersonEtAl2012}\n\n\nYou may also be interested in a particular gradient or a single summary statistic. For example, a bivariate regressogram can estimate the marginal effect of $X_{1}$ at the means; $\\widehat{\\beta_{1}}(\\overline{\\mathbf{x}}=[\\overline{x_{1}}, \\overline{x_{2}}])$. You may also be interested in the mean of the marginal effects (sometimes said simply as \"average effect\"), which averages the marginal effect over all datapoints in the dataset: $1/n \\sum_{i}^{n} \\widehat{\\beta_{1}}(\\mathbf{X}_{i})$, or the median marginal effect. Such statistics are single numbers that can be presented similar to an OLS regression table where each row corresponds a variable and each cell has two elements: \"mean gradient (sd gradient)\".\n\n\n\n## More Literature\n\n\nDiagnostics\n\n* <https://book.stat420.org/model-diagnostics.html#leverage>\n* <https://socialsciences.mcmaster.ca/jfox/Books/RegressionDiagnostics/index.html>\n* <https://bookdown.org/ripberjt/labbook/diagnosing-and-addressing-problems-in-linear-regression.html>\n* Belsley, D. A., Kuh, E., and Welsch, R. E. (1980). Regression Diagnostics: Identifying influential data and sources of collinearity. Wiley. <https://doi.org/10.1002/0471725153>\n* Fox, J. D. (2020). Regression diagnostics: An introduction (2nd ed.). SAGE. <https://dx.doi.org/10.4135/9781071878651>\n\n",
    "supporting": [
      "03_02_InterprettingRegression_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}