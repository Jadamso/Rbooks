{
  "hash": "25907361561b2e38ccc464c9741da439",
  "result": {
    "engine": "knitr",
    "markdown": "\n# Mathematics\n***\n\n\n\n## Objects\n\nIn R: scalars, vectors, and matrices are different kinds of \"objects\". \n\nThese objects are used extensively in data analysis\n\n* *scalars*: summary statistics (average household income).\n* *vectors*: single variables in data sets (the household income of each family in Vancouver).\n* *matrices*: two variables in data sets (the age and education level of every person in class).\n\n\nVectors are probably your most common object in R, but we will start with scalars.\n\n\n#### **Scalars**. {-}\n\nMake your first scalar\n\n::: {.cell}\n\n```{.r .cell-code}\nxs <- 2 # Make your first scalar\nxs  # Print the scalar\n## [1] 2\n```\n:::\n\n\nPerform simple calculations and see how R is doing the math for you\n\n::: {.cell}\n\n```{.r .cell-code}\nxs + 2\n## [1] 4\nxs*2 # Perform and print a simple calculation\n## [1] 4\n(xs+1)^2 # Perform and print a simple calculation\n## [1] 9\nxs + NA # often used for missing values\n## [1] NA\n```\n:::\n\n\nNow change `xs`, predict what will happen, then re-run the code.\n\n#### **Vectors**. {-}\n\nMake Your First Vector\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(0,1,3,10,6) # Your First Vector\nx # Print the vector\n## [1]  0  1  3 10  6\nx[2] # Print the 2nd Element; 1\n## [1] 1\nx+2 # Print simple calculation; 2,3,5,8,12\n## [1]  2  3  5 12  8\nx*2\n## [1]  0  2  6 20 12\nx^2\n## [1]   0   1   9 100  36\n```\n:::\n\n\nApply Mathematical calculations \"elementwise\"\n\n::: {.cell}\n\n```{.r .cell-code}\nx+x\n## [1]  0  2  6 20 12\nx*x\n## [1]   0   1   9 100  36\nx^x\n## [1] 1.0000e+00 1.0000e+00 2.7000e+01 1.0000e+10 4.6656e+04\n```\n:::\n\n\nIn R, scalars are treated as a vector with one element.\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1)\n## [1] 1\n```\n:::\n\n\nSometimes, we will use vectors that are entirely ordered. \n\n::: {.cell}\n\n```{.r .cell-code}\n1:7\n## [1] 1 2 3 4 5 6 7\nseq(0,1,by=.1)\n##  [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0\n\n# Ordering data\nsort(x)\n## [1]  0  1  3  6 10\nx[order(x)]\n## [1]  0  1  3  6 10\n```\n:::\n\n\n\n#### **Matrices**. {-}\n\nMatrices are also common objects\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- c(1,4,9)\nx2 <- c(3,0,2)\nx_mat <- rbind(x1, x2)\n\nx_mat       # Print full matrix\n##    [,1] [,2] [,3]\n## x1    1    4    9\n## x2    3    0    2\nx_mat[2,]   # Print Second Row\n## [1] 3 0 2\nx_mat[,2]   # Print Second Column\n## x1 x2 \n##  4  0\nx_mat[2,2]  # Print Element in Second Column and Second Row\n## x2 \n##  0\n```\n:::\n\n\nThere are elementwise calculations\n\n::: {.cell}\n\n```{.r .cell-code}\nx_mat+2\n##    [,1] [,2] [,3]\n## x1    3    6   11\n## x2    5    2    4\nx_mat*2\n##    [,1] [,2] [,3]\n## x1    2    8   18\n## x2    6    0    4\nx_mat^2\n##    [,1] [,2] [,3]\n## x1    1   16   81\n## x2    9    0    4\n\nx_mat + x_mat\n##    [,1] [,2] [,3]\n## x1    2    8   18\n## x2    6    0    4\nx_mat*x_mat\n##    [,1] [,2] [,3]\n## x1    1   16   81\n## x2    9    0    4\nx_mat^x_mat\n##    [,1] [,2]      [,3]\n## x1    1  256 387420489\n## x2   27    1         4\n```\n:::\n\n\n\nAnd you can also use matrix algebra\n\n::: {.cell}\n\n```{.r .cell-code}\nx_mat1 <- matrix(2:7,2,3)\nx_mat1\n##      [,1] [,2] [,3]\n## [1,]    2    4    6\n## [2,]    3    5    7\n\nx_mat2 <- matrix(4:-1,2,3)\nx_mat2\n##      [,1] [,2] [,3]\n## [1,]    4    2    0\n## [2,]    3    1   -1\n\ntcrossprod(x_mat1, x_mat2) #x_mat1 %*% t(x_mat2)\n##      [,1] [,2]\n## [1,]   16    4\n## [2,]   22    7\n\ncrossprod(x_mat1, x_mat2)\n##      [,1] [,2] [,3]\n## [1,]   17    7   -3\n## [2,]   31   13   -5\n## [3,]   45   19   -7\n```\n:::\n\n\n\n##  Functions\n\nFunctions are applied to objects\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define a function that adds two to any vector\nadd_2 <- function(input_vector) {\n    output_vector <- input_vector + 2 # new object defined locally \n    return(output_vector) # return new object \n}\n# Apply that function to a vector\nx <- c(0,1,3,10,6)\nadd_2(x)\n## [1]  2  3  5 12  8\n\n# notice 'output_vector' is not available here\n```\n:::\n\n\nThere are many many generalizations\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_vec <- function(input_vector1, input_vector2) {\n    output_vector <- input_vector1 + input_vector2\n    return(output_vector)\n}\nadd_vec(x,3)\n## [1]  3  4  6 13  9\nadd_vec(x,x)\n## [1]  0  2  6 20 12\n\nsum_squared <- function(x1, x2) {\n    y <- (x1 + x2)^2\n    return(y)\n}\n\nsum_squared(1, 3)\n## [1] 16\nsum_squared(x, 2)\n## [1]   4   9  25 144  64\nsum_squared(x, NA) \n## [1] NA NA NA NA NA\nsum_squared(x, x)\n## [1]   0   4  36 400 144\nsum_squared(x, 2*x)\n## [1]   0   9  81 900 324\n```\n:::\n\n\nFunctions can take functions as arguments\n\n::: {.cell}\n\n```{.r .cell-code}\nfun_of_seq <- function(f){\n    x <- seq(1,3, length.out=12)\n    y <- f(x)\n    return(y)\n}\n\nfun_of_seq(mean)\n## [1] 2\n\nfun_of_seq(sd)\n## [1] 0.6555548\n```\n:::\n\n\nYou can apply functions to matrices\n\n::: {.cell}\n\n```{.r .cell-code}\nsum_squared(x_mat, x_mat)\n##    [,1] [,2] [,3]\n## x1    4   64  324\n## x2   36    0   16\n\n# Apply function to each matrix row\ny <- apply(x_mat, 1, sum)^2 \n# ?apply  #checks the function details\ny - sum_squared(x, x) # tests if there are any differences\n## [1]  196   21  160 -375   52\n```\n:::\n\n\nThere are many possible functions you can apply\n\n::: {.cell}\n\n```{.r .cell-code}\n# Return Y-value with minimum absolute difference from 3\nabs_diff_y <- abs( y - 3 ) \nabs_diff_y # is this the luckiest number?\n##  x1  x2 \n## 193  22\n\n#min(abs_diff_y)\n#which.min(abs_diff_y)\ny[ which.min(abs_diff_y) ]\n## x2 \n## 25\n```\n:::\n\n\nThere are also some useful built in functions\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(c(1:3,2*(1:3)),byrow=TRUE,ncol=3)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    2    3\n## [2,]    2    4    6\n\n# normalize rows\nm/rowSums(m)\n##           [,1]      [,2] [,3]\n## [1,] 0.1666667 0.3333333  0.5\n## [2,] 0.1666667 0.3333333  0.5\n\n# normalize columns\nt(t(m)/colSums(m))\n##           [,1]      [,2]      [,3]\n## [1,] 0.3333333 0.3333333 0.3333333\n## [2,] 0.6666667 0.6666667 0.6666667\n\n# de-mean rows\nsweep(m,1,rowMeans(m), '-')\n##      [,1] [,2] [,3]\n## [1,]   -1    0    1\n## [2,]   -2    0    2\n\n# de-mean columns\nsweep(m,2,colMeans(m), '-')\n##      [,1] [,2] [,3]\n## [1,] -0.5   -1 -1.5\n## [2,]  0.5    1  1.5\n```\n:::\n\n\n\n#### **Loops**. {-}\n\nApplying the same function over and over again\n\n::: {.cell}\n\n```{.r .cell-code}\nexp_vector <- vector(length=3)\nfor(i in 1:3){\n    exp_vector[i] <- exp(i)\n}\n\n# Compare\nexp_vector\n## [1]  2.718282  7.389056 20.085537\nc( exp(1), exp(2), exp(3))\n## [1]  2.718282  7.389056 20.085537\n```\n:::\n\n\nstore complicated example\n\n::: {.cell}\n\n```{.r .cell-code}\ncomplicate_fun <- function(i, j=0){\n    x <- i^(i-1)\n    y <- x + mean( j:i )\n    z <- log(y)/i\n    return(z)\n}\ncomplicated_vector <- vector(length=10)\nfor(i in 1:10){\n    complicated_vector[i] <- complicate_fun(i)\n}\n```\n:::\n\n\nrecursive loop\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- vector(length=4)\nx[1] <- 1\nfor(i in 2:4){\n    x[i] <- (x[i-1]+1)^2\n}\nx\n## [1]   1   4  25 676\n```\n:::\n\n\n<!---\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# for loop in a function\nr_fun <- function(n){\n    x <- rep(1,n)\n    for(i in 2:length(x) ){\n        x[i] <- (x[i-1]+1)^2\n    }\n    return(x)\n}\nr_fun(5)\n## [1]      1      4     25    676 458329\n```\n:::\n\n--->\n\n\n#### **Logic**. {-}\n\nBasic Logic\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1,2,3,NA)\nx > 2\n## [1] FALSE FALSE  TRUE    NA\nx==2\n## [1] FALSE  TRUE FALSE    NA\n\nany(x==2)\n## [1] TRUE\nall(x==2)\n## [1] FALSE\n2 %in% x\n## [1] TRUE\n\nis.numeric(x)\n## [1] TRUE\nis.na(x)\n## [1] FALSE FALSE FALSE  TRUE\n```\n:::\n\n\nThe \"&\" and \"|\" commands are logical calculations that compare vectors to the left and right.\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:3\nis.numeric(x) & (x < 2)\n## [1]  TRUE FALSE FALSE\nis.numeric(x) | (x < 2)\n## [1] TRUE TRUE TRUE\n\nif(length(x) >= 5 & x[5] > 12) print(\"ok\")\n```\n:::\n\n\nAdvanced Logic.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\ncut(x, 4)\n##  [1] (0.991,3.25] (0.991,3.25] (0.991,3.25] (3.25,5.5]   (3.25,5.5]  \n##  [6] (5.5,7.75]   (5.5,7.75]   (7.75,10]    (7.75,10]    (7.75,10]   \n## Levels: (0.991,3.25] (3.25,5.5] (5.5,7.75] (7.75,10]\nsplit(x, cut(x, 4))\n## $`(0.991,3.25]`\n## [1] 1 2 3\n## \n## $`(3.25,5.5]`\n## [1] 4 5\n## \n## $`(5.5,7.75]`\n## [1] 6 7\n## \n## $`(7.75,10]`\n## [1]  8  9 10\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxs <- split(x, cut(x, 4))\nsapply(xs, mean)\n## (0.991,3.25]   (3.25,5.5]   (5.5,7.75]    (7.75,10] \n##          2.0          4.5          6.5          9.0\n\n# shortcut\naggregate(x, list(cut(x,4)), mean)\n##        Group.1   x\n## 1 (0.991,3.25] 2.0\n## 2   (3.25,5.5] 4.5\n## 3   (5.5,7.75] 6.5\n## 4    (7.75,10] 9.0\n```\n:::\n\n\nsee https://bookdown.org/rwnahhas/IntroToR/logical.html\n\n\n## Datasets\n\nDatasets can be stored in a variety of formats on your computer. But they can be analyzed in R in three basic ways.\n\n#### **Lists**. {-}\n\nLists are probably the most basic type\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\ny <- 2*x\nlist(x, y)  # list of vectors\n## [[1]]\n##  [1]  1  2  3  4  5  6  7  8  9 10\n## \n## [[2]]\n##  [1]  2  4  6  8 10 12 14 16 18 20\n\nlist(x_mat1, x_mat2)  # list of matrices\n## [[1]]\n##      [,1] [,2] [,3]\n## [1,]    2    4    6\n## [2,]    3    5    7\n## \n## [[2]]\n##      [,1] [,2] [,3]\n## [1,]    4    2    0\n## [2,]    3    1   -1\n```\n:::\n\n\nLists are useful for storing unstructured data\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(list(x_mat1), list(x_mat2))  # list of lists\n## [[1]]\n## [[1]][[1]]\n##      [,1] [,2] [,3]\n## [1,]    2    4    6\n## [2,]    3    5    7\n## \n## \n## [[2]]\n## [[2]][[1]]\n##      [,1] [,2] [,3]\n## [1,]    4    2    0\n## [2,]    3    1   -1\n\nlist(x_mat1, list(x_mat1, x_mat2)) # list of different objects\n## [[1]]\n##      [,1] [,2] [,3]\n## [1,]    2    4    6\n## [2,]    3    5    7\n## \n## [[2]]\n## [[2]][[1]]\n##      [,1] [,2] [,3]\n## [1,]    2    4    6\n## [2,]    3    5    7\n## \n## [[2]][[2]]\n##      [,1] [,2] [,3]\n## [1,]    4    2    0\n## [2,]    3    1   -1\n\n# ...inception...\nlist(x_mat1,\n    list(x_mat1, x_mat2), \n    list(x_mat1, list(x_mat2)\n    )) \n## [[1]]\n##      [,1] [,2] [,3]\n## [1,]    2    4    6\n## [2,]    3    5    7\n## \n## [[2]]\n## [[2]][[1]]\n##      [,1] [,2] [,3]\n## [1,]    2    4    6\n## [2,]    3    5    7\n## \n## [[2]][[2]]\n##      [,1] [,2] [,3]\n## [1,]    4    2    0\n## [2,]    3    1   -1\n## \n## \n## [[3]]\n## [[3]][[1]]\n##      [,1] [,2] [,3]\n## [1,]    2    4    6\n## [2,]    3    5    7\n## \n## [[3]][[2]]\n## [[3]][[2]][[1]]\n##      [,1] [,2] [,3]\n## [1,]    4    2    0\n## [2,]    3    1   -1\n```\n:::\n\n\n#### **Data.frames**. {-}\n\nA *data.frame* looks like a matrix but each column is actually a list rather than a vector. This allows you to combine different data types into a single object for analysis, which is why it might be your most common object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# data.frames: \n    # matrix of different data-types\n    # well-ordered lists\ndata.frame(x, y)  # list of vectors\n##     x  y\n## 1   1  2\n## 2   2  4\n## 3   3  6\n## 4   4  8\n## 5   5 10\n## 6   6 12\n## 7   7 14\n## 8   8 16\n## 9   9 18\n## 10 10 20\n```\n:::\n\n\n#### **Arrays**. {-}\n\nArrays are generalization of matrices to multiple dimensions. They are a very efficient way to store numeric data with the same dimensions, and are often used in spatial econometrics and time series (often in the form of \"data cubes\").\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# data square (matrix)\narray(data = 1:24, dim = c(3,8))\n##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]\n## [1,]    1    4    7   10   13   16   19   22\n## [2,]    2    5    8   11   14   17   20   23\n## [3,]    3    6    9   12   15   18   21   24\n\n# data cube\na <- array(data = 1:24, dim = c(3, 2, 4))\na\n## , , 1\n## \n##      [,1] [,2]\n## [1,]    1    4\n## [2,]    2    5\n## [3,]    3    6\n## \n## , , 2\n## \n##      [,1] [,2]\n## [1,]    7   10\n## [2,]    8   11\n## [3,]    9   12\n## \n## , , 3\n## \n##      [,1] [,2]\n## [1,]   13   16\n## [2,]   14   17\n## [3,]   15   18\n## \n## , , 4\n## \n##      [,1] [,2]\n## [1,]   19   22\n## [2,]   20   23\n## [3,]   21   24\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na[1, , , drop = FALSE]  # Row 1\n#a[, 1, , drop = FALSE]  # Column 1\n#a[, , 1, drop = FALSE]  # Layer 1\n\na[ 1, 1,  ]  # Row 1, column 1\n#a[ 1,  , 1]  # Row 1, \"layer\" 1\n#a[  , 1, 1]  # Column 1, \"layer\" 1\na[1 , 1, 1]  # Row 1, column 1, \"layer\" 1\n```\n:::\n\n\nApply extends to arrays\n\n::: {.cell}\n\n```{.r .cell-code}\napply(a, 1, mean)    # Row means\n## [1] 11.5 12.5 13.5\napply(a, 2, mean)    # Column means\n## [1] 11 14\napply(a, 3, mean)    # \"Layer\" means\n## [1]  3.5  9.5 15.5 21.5\napply(a, 1:2, mean)  # Row/Column combination \n##      [,1] [,2]\n## [1,]   10   13\n## [2,]   11   14\n## [3,]   12   15\n```\n:::\n\n\nOuter products yield arrays\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1,2,3)\nx_mat1 <- outer(x, x) # x %o% x\nx_mat1\n##      [,1] [,2] [,3]\n## [1,]    1    2    3\n## [2,]    2    4    6\n## [3,]    3    6    9\nis.array(x_mat) # Matrices are arrays\n## [1] TRUE\n\nx_mat2 <- matrix(6:1,2,3)\nouter(x_mat2, x)\n## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]    6    4    2\n## [2,]    5    3    1\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]   12    8    4\n## [2,]   10    6    2\n## \n## , , 3\n## \n##      [,1] [,2] [,3]\n## [1,]   18   12    6\n## [2,]   15    9    3\n# outer(x_mat2, matrix(x))\n# outer(x_mat2, t(x))\n# outer(x_mat1, x_mat2)\n```\n:::\n\n",
    "supporting": [
      "01_02_Mathematics_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}