{
  "hash": "9bc7b286454e9321b8fde56c007b0c6a",
  "result": {
    "engine": "knitr",
    "markdown": "\n# Mathematics\n***\n\n\n\n## Objects\n\nIn R: scalars, vectors, and matrices are different kinds of \"objects\". \n\nThese objects are used extensively in data analysis\n\n* *scalars*: summary statistics (average household income).\n* *vectors*: single variables in data sets (the household income of each family in Vancouver).\n* *matrices*: two variables in data sets (the age and education level of every person in class).\n\n\nVectors are probably your most common object in R, but we will start with scalars.\n\n\n#### **Scalars**. {-}\n\nMake your first scalar\n\n::: {.cell}\n\n```{.r .cell-code}\nxs <- 2 # Make your first scalar\nxs  # Print the scalar\n## [1] 2\n```\n:::\n\n\nPerform simple calculations and see how R is doing the math for you\n\n::: {.cell}\n\n```{.r .cell-code}\nxs + 2\n## [1] 4\nxs*2 # Perform and print a simple calculation\n## [1] 4\n(xs+1)^2 # Perform and print a simple calculation\n## [1] 9\nxs + NA # often used for missing values\n## [1] NA\n```\n:::\n\n\nNow change `xs`, predict what will happen, then re-run the code.\n\n#### **Vectors**. {-}\n\nMake Your First Vector\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(0,1,3,10,6) # Your First Vector\nx # Print the vector\n## [1]  0  1  3 10  6\nx[2] # Print the 2nd Element; 1\n## [1] 1\nx+2 # Print simple calculation; 2,3,5,8,12\n## [1]  2  3  5 12  8\nx*2\n## [1]  0  2  6 20 12\nx^2\n## [1]   0   1   9 100  36\n```\n:::\n\n\nApply mathematical calculations elementwise\n\n::: {.cell}\n\n```{.r .cell-code}\nx+x\n## [1]  0  2  6 20 12\nx*x\n## [1]   0   1   9 100  36\nx^x\n## [1] 1.0000e+00 1.0000e+00 2.7000e+01 1.0000e+10 4.6656e+04\n```\n:::\n\n\nIn R, scalars are treated as a vector with one element.\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1)\n## [1] 1\n```\n:::\n\n\nSometimes, we will use vectors that are entirely ordered. \n\n::: {.cell}\n\n```{.r .cell-code}\n1:7\n## [1] 1 2 3 4 5 6 7\nseq(0,1,by=.1)\n##  [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0\n\n# Ordering data\nsort(x)\n## [1]  0  1  3  6 10\nx[order(x)]\n## [1]  0  1  3  6 10\n```\n:::\n\n\n\n#### **Matrices**. {-}\n\nMatrices are also common objects\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- c(1,4,9)\nx2 <- c(3,0,2)\nx_mat <- rbind(x1, x2)\n\nx_mat       # Print full matrix\n##    [,1] [,2] [,3]\n## x1    1    4    9\n## x2    3    0    2\nx_mat[2,]   # Print Second Row\n## [1] 3 0 2\nx_mat[,2]   # Print Second Column\n## x1 x2 \n##  4  0\nx_mat[2,2]  # Print Element in Second Column and Second Row\n## x2 \n##  0\n```\n:::\n\n\nThere are elementwise calculations\n\n::: {.cell}\n\n```{.r .cell-code}\nx_mat+2\n##    [,1] [,2] [,3]\n## x1    3    6   11\n## x2    5    2    4\nx_mat*2\n##    [,1] [,2] [,3]\n## x1    2    8   18\n## x2    6    0    4\nx_mat^2\n##    [,1] [,2] [,3]\n## x1    1   16   81\n## x2    9    0    4\n\nx_mat + x_mat\n##    [,1] [,2] [,3]\n## x1    2    8   18\n## x2    6    0    4\nx_mat*x_mat #NOT classical matrix multiplication\n##    [,1] [,2] [,3]\n## x1    1   16   81\n## x2    9    0    4\nx_mat^x_mat\n##    [,1] [,2]      [,3]\n## x1    1  256 387420489\n## x2   27    1         4\n```\n:::\n\n\n\nAnd you can also use matrix algebra\n\n::: {.cell}\n\n```{.r .cell-code}\nx_mat1 <- matrix(2:7,2,3)\nx_mat1\n##      [,1] [,2] [,3]\n## [1,]    2    4    6\n## [2,]    3    5    7\n\nx_mat2 <- matrix(4:-1,2,3)\nx_mat2\n##      [,1] [,2] [,3]\n## [1,]    4    2    0\n## [2,]    3    1   -1\n\ntcrossprod(x_mat1, x_mat2) #x_mat1 %*% t(x_mat2)\n##      [,1] [,2]\n## [1,]   16    4\n## [2,]   22    7\n\ncrossprod(x_mat1, x_mat2)\n##      [,1] [,2] [,3]\n## [1,]   17    7   -3\n## [2,]   31   13   -5\n## [3,]   45   19   -7\n```\n:::\n\n\n\n##  Functions\n\n#### **Basic Functions**. {-}\n\nFunctions are applied to objects\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define a function that adds two to any vector\nadd_two <- function(input_vector) { #input_vector is a placeholder\n    output_vector <- input_vector + 2 # new object defined locally \n    return(output_vector) # return new object \n}\n# Apply that function to a vector\nx <- c(0,1,3,10,6)\nadd_two(input_vector=x) #same as add_two(x)\n## [1]  2  3  5 12  8\n```\n:::\n\n\nCommon mistakes:\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(output_vector)\n# This is not available globally\n\n# Seeing \"+ add_2(x)\" in the bottom console\n# means you forgot to close the function with \"}\" \n# press \"Escape\" and try again\n\n# Double check your spelling\n```\n:::\n\n\nThere are many many generalizations\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_vec <- function(input_vector1, input_vector2) {\n    output_vector <- input_vector1 + input_vector2\n    return(output_vector)\n}\nadd_vec(x,3)\n## [1]  3  4  6 13  9\nadd_vec(x,x)\n## [1]  0  2  6 20 12\n\nsum_squared <- function(x1, x2) {\n    y <- (x1 + x2)^2\n    return(y)\n}\n\nsum_squared(1, 3)\n## [1] 16\nsum_squared(x, 2)\n## [1]   4   9  25 144  64\nsum_squared(x, NA) \n## [1] NA NA NA NA NA\nsum_squared(x, x)\n## [1]   0   4  36 400 144\nsum_squared(x, 2*x)\n## [1]   0   9  81 900 324\n```\n:::\n\n\nFunctions can take functions as arguments. Note that a *statistic* is defined as a function of data.\n\n::: {.cell}\n\n```{.r .cell-code}\nstatistic <- function(x,f){\n    y <- f(x)\n    return(y)\n}\nstatistic(x, mean)\n## [1] 4\n```\n:::\n\n\n\nYou can apply functions to matrices\n\n::: {.cell}\n\n```{.r .cell-code}\nsum_squared(x_mat, x_mat)\n##    [,1] [,2] [,3]\n## x1    4   64  324\n## x2   36    0   16\n\n# Apply function to each matrix row\ny <- apply(x_mat, 1, sum)^2 \n# ?apply  #checks the function details\ny - sum_squared(x, x) # tests if there are any differences\n## [1]  196   21  160 -375   52\n```\n:::\n\n\n\n#### **Advanced Functions**. {-}\n\nThere are many possible functions you can apply\n\n::: {.cell}\n\n```{.r .cell-code}\n# Return Y-value with minimum absolute difference from 3\nabs_diff_y <- abs( y - 3 ) \nabs_diff_y # is this the luckiest number?\n##  x1  x2 \n## 193  22\n\n#min(abs_diff_y)\n#which.min(abs_diff_y)\ny[ which.min(abs_diff_y) ]\n## x2 \n## 25\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfun_of_seq <- function(f){\n    x1 <- seq(1,3, length.out=12)\n    x2 <- x1+2\n    x <- cbind(x1,x2)\n    y <- f(x)\n    return(y)\n}\nfun_of_seq(mean)\n## [1] 3\nfun_of_seq(sd)\n## [1] 1.206045\n```\n:::\n\n\n\nThere are also some useful built in functions\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(c(1:3,2*(1:3)),byrow=TRUE,ncol=3)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    2    3\n## [2,]    2    4    6\n\n# normalize rows\nm/rowSums(m)\n##           [,1]      [,2] [,3]\n## [1,] 0.1666667 0.3333333  0.5\n## [2,] 0.1666667 0.3333333  0.5\n\n# normalize columns\nt(t(m)/colSums(m))\n##           [,1]      [,2]      [,3]\n## [1,] 0.3333333 0.3333333 0.3333333\n## [2,] 0.6666667 0.6666667 0.6666667\n\n# de-mean rows\nsweep(m,1,rowMeans(m), '-')\n##      [,1] [,2] [,3]\n## [1,]   -1    0    1\n## [2,]   -2    0    2\n\n# de-mean columns\nsweep(m,2,colMeans(m), '-')\n##      [,1] [,2] [,3]\n## [1,] -0.5   -1 -1.5\n## [2,]  0.5    1  1.5\n```\n:::\n\n\n\n#### **Loops**. {-}\n\nApplying the same function over and over again\n\n::: {.cell}\n\n```{.r .cell-code}\n#Create empty vector\nexp_vector <- vector(length=3)\n#Fill empty vector\nfor(i in 1:3){\n    exp_vector[i] <- exp(i)\n}\n\n# Compare\nexp_vector\n## [1]  2.718282  7.389056 20.085537\nc( exp(1), exp(2), exp(3))\n## [1]  2.718282  7.389056 20.085537\n```\n:::\n\n\nA more complicated example\n\n::: {.cell}\n\n```{.r .cell-code}\ncomplicated_fun <- function(i, j=0){\n    x <- i^(i-1)\n    y <- x + mean( j:i )\n    z <- log(y)/i\n    return(z)\n}\ncomplicated_vector <- vector(length=10)\nfor(i in 1:10){\n    complicated_vector[i] <- complicated_fun(i)\n}\n```\n:::\n\n\nA recursive example\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- vector(length=4)\nx[1] <- 1\nfor(i in 2:4){\n    x[i] <- (x[i-1]+1)^2\n}\nx\n## [1]   1   4  25 676\n```\n:::\n\n\n<!---\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# for loop in a function\nr_fun <- function(n){\n    x <- rep(1,n)\n    for(i in 2:length(x) ){\n        x[i] <- (x[i-1]+1)^2\n    }\n    return(x)\n}\nr_fun(5)\n## [1]      1      4     25    676 458329\n```\n:::\n\n--->\n\n\n## Special Functions\n\n#### **Basic Logic**. {-}\n\nTRUE/FALSE\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1,2,3,NA)\nx > 2\n## [1] FALSE FALSE  TRUE    NA\nx==2\n## [1] FALSE  TRUE FALSE    NA\n\nany(x==2)\n## [1] TRUE\nall(x==2)\n## [1] FALSE\n2 %in% x\n## [1] TRUE\n\n2==TRUE\n## [1] FALSE\n2==FALSE\n## [1] FALSE\n \nis.numeric(x)\n## [1] TRUE\nis.na(x)\n## [1] FALSE FALSE FALSE  TRUE\n```\n:::\n\n\nThe \"&\" and \"|\" commands are logical calculations that compare vectors to the left and right.\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:3\nis.numeric(x) & (x < 2)\n## [1]  TRUE FALSE FALSE\nis.numeric(x) | (x < 2)\n## [1] TRUE TRUE TRUE\n\nif(length(x) >= 5 & x[5] > 12) print(\"ok\")\n```\n:::\n\n\n#### **Basic Counting**. {-}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactorial(4)\n## [1] 24\n\nchoose(4,2)\n## [1] 6\n```\n:::\n\n\n#### **Advanced Logic**. {-}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\ncut(x, 4)\n##  [1] (0.991,3.25] (0.991,3.25] (0.991,3.25] (3.25,5.5]   (3.25,5.5]  \n##  [6] (5.5,7.75]   (5.5,7.75]   (7.75,10]    (7.75,10]    (7.75,10]   \n## Levels: (0.991,3.25] (3.25,5.5] (5.5,7.75] (7.75,10]\nsplit(x, cut(x, 4))\n## $`(0.991,3.25]`\n## [1] 1 2 3\n## \n## $`(3.25,5.5]`\n## [1] 4 5\n## \n## $`(5.5,7.75]`\n## [1] 6 7\n## \n## $`(7.75,10]`\n## [1]  8  9 10\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxs <- split(x, cut(x, 4))\nsapply(xs, mean)\n## (0.991,3.25]   (3.25,5.5]   (5.5,7.75]    (7.75,10] \n##          2.0          4.5          6.5          9.0\n\n# shortcut\naggregate(x, list(cut(x,4)), mean)\n##        Group.1   x\n## 1 (0.991,3.25] 2.0\n## 2   (3.25,5.5] 4.5\n## 3   (5.5,7.75] 6.5\n## 4    (7.75,10] 9.0\n```\n:::\n\n\nSee <https://bookdown.org/rwnahhas/IntroToR/logical.html>\n\n\n\n",
    "supporting": [
      "01_02_Mathematics_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}